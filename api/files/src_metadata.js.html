---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/admin.html">admin</a></li>
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/user.html">user</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/admin.html">admin</a></li>
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/user.html">user</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v4.5.0</span>
                        <h1 class="file-heading">File: src/metadata.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // Copyright (C) 2007-2014, GoodData(R) Corporation. All rights reserved.
                        import {
                            isPlainObject,
                            get as _get,
                            chunk,
                            flatten,
                            pick
                        } from &#x27;lodash&#x27;;
                        import { ajax, get, post, del, parseJSON } from &#x27;./xhr&#x27;;
                        import { getIn, handlePolling, queryString } from &#x27;./util&#x27;;
                        
                        /**
                         * Functions for working with metadata objects
                         *
                         * @class metadata
                         * @module metadata
                         */
                        
                        /**
                         * Load all objects with given uris
                         * (use bulk loading instead of getting objects one by one)
                         *
                         * @method getObjects
                         * @param {String} projectId id of the project
                         * @param {Array} objectUris array of uris for objects to be loaded
                         * @return {Array} array of loaded elements
                         */
                        export function getObjects(projectId, objectUris) {
                            const LIMIT = 50;
                            const uri = &#x60;/gdc/md/${projectId}/objects/get&#x60;;
                        
                            const objectsUrisChunks = chunk(objectUris, LIMIT);
                        
                            const promises = objectsUrisChunks.map((objectUrisChunk) =&gt; {
                                const data = {
                                    get: {
                                        items: objectUrisChunk
                                    }
                                };
                        
                                return post(uri, {
                                    data: JSON.stringify(data)
                                }).then((r) =&gt; {
                                    if (!r.ok) {
                                        const err = new Error(r.statusText);
                                        err.response = r;
                                        throw err;
                                    }
                        
                                    return r.json();
                                }).then(result =&gt; _get(result, [&#x27;objects&#x27;, &#x27;items&#x27;]));
                            });
                        
                            return Promise.all(promises).then(flatten);
                        }
                        
                        /**
                         * Loads all objects by query (fetches all pages, one by one)
                         *
                         * @method getObjectsByQuery
                         * @param {String} projectId id of the project
                         * @param {Object} options (see https://developer.gooddata.com/api endpoint: /gdc/md/{project_id}/objects/query)
                         *        - category {String} for example &#x27;dataSets&#x27; or &#x27;projectDashboard&#x27;
                         *        - mode {String} &#x27;enriched&#x27; or &#x27;raw&#x27;
                         *        - author {String} the URI of the author of the metadata objects
                         *        - limit {number} default is 50 (also maximum)
                         * @return {Promise&lt;Array&gt;} array of returned objects
                         */
                        export function getObjectsByQuery(projectId, options) {
                            function getOnePage(uri, items = []) {
                                return get(uri)
                                    .then(({ objects }) =&gt; {
                                        items.push(...objects.items);
                                        const nextUri = objects.paging.next;
                                        return nextUri ? getOnePage(nextUri, items) : items;
                                    });
                            }
                        
                            const uri = &#x60;/gdc/md/${projectId}/objects/query&#x60;;
                            const query = pick({ limit: 50, ...options }, [&#x27;category&#x27;, &#x27;mode&#x27;, &#x27;author&#x27;, &#x27;limit&#x27;]);
                            return getOnePage(uri + queryString(query));
                        }
                        
                        
                        /**
                         * Get MD objects from using2 resource. Include only objects of given types
                         * and take care about fetching only nearest objects if requested.
                         *
                         * @method getObjectUsing
                         * @param {String} projectId id of the project
                         * @param {String} uri uri of the object for which dependencies are to be found
                         * @param {Object} options objects with options:
                         *        - types {Array} array of strings with object types to be included
                         *        - nearest {Boolean} whether to include only nearest dependencies
                         * @return {jQuery promise} promise promise once resolved returns an array of
                         *         entries returned by using2 resource
                         */
                        export function getObjectUsing(projectId, uri, options = {}) {
                            const { types = [], nearest = false } = options;
                            const resourceUri = &#x60;/gdc/md/${projectId}/using2&#x60;;
                        
                            const data = {
                                inUse: {
                                    uri,
                                    types,
                                    nearest: nearest ? 1 : 0
                                }
                            };
                        
                            return post(resourceUri, {
                                data: JSON.stringify(data)
                            }).then((r) =&gt; {
                                if (!r.ok) {
                                    const err = new Error(r.statusText);
                                    err.response = r;
                                    throw err;
                                }
                        
                                return r.json();
                            }).then(result =&gt; result.entries);
                        }
                        
                        /**
                         * Get MD objects from using2 resource. Include only objects of given types
                         * and take care about fetching only nearest objects if requested.
                         *
                         * @method getObjectUsingMany
                         * @param {String} projectId id of the project
                         * @param {Array} uris uris of objects for which dependencies are to be found
                         * @param {Object} options objects with options:
                         *        - types {Array} array of strings with object types to be included
                         *        - nearest {Boolean} whether to include only nearest dependencies
                         * @return {jQuery promise} promise promise once resolved returns an array of
                         *         entries returned by using2 resource
                         */
                        export function getObjectUsingMany(projectId, uris, options = {}) {
                            const { types = [], nearest = false } = options;
                            const resourceUri = &#x60;/gdc/md/${projectId}/using2&#x60;;
                        
                            const data = {
                                inUseMany: {
                                    uris,
                                    types,
                                    nearest: nearest ? 1 : 0
                                }
                            };
                        
                            return post(resourceUri, {
                                data: JSON.stringify(data)
                            }).then((r) =&gt; {
                                if (!r.ok) {
                                    const err = new Error(r.statusText);
                                    err.response = r;
                                    throw err;
                                }
                        
                                return r.json();
                            }).then(result =&gt; result.useMany);
                        }
                        
                        /**
                         * Returns all visualizations metadata in a project specified by projectId param
                         *
                         * @method getVisualizations
                         * @param {string} projectId Project identifier
                         * @return {Array} An array of visualization objects
                         */
                        export function getVisualizations(projectId) {
                            return get(&#x60;/gdc/md/${projectId}/query/visualizations&#x60;).then(r =&gt; (r.ok ? r.json() : r)).then(getIn(&#x27;query.entries&#x27;));
                        }
                        
                        /**
                        * Returns all attributes in a project specified by projectId param
                        *
                        * @method getAttributes
                        * @param {string} projectId Project identifier
                        * @return {Array} An array of attribute objects
                        */
                        export function getAttributes(projectId) {
                            return get(&#x60;/gdc/md/${projectId}/query/attributes&#x60;).then(r =&gt; (r.ok ? r.json() : r)).then(getIn(&#x27;query.entries&#x27;));
                        }
                        
                        /**
                         * Returns all dimensions in a project specified by projectId param
                         *
                         * @method getDimensions
                         * @param {string} projectId Project identifier
                         * @return {Array} An array of dimension objects
                         * @see getFolders
                         */
                        export function getDimensions(projectId) {
                            return get(&#x60;/gdc/md/${projectId}/query/dimensions&#x60;).then(r =&gt; (r.ok ? r.json() : r)).then(getIn(&#x27;query.entries&#x27;));
                        }
                        
                        /**
                         * Returns project folders. Folders can be of specific types and you can specify
                         * the type you need by passing and optional &#x60;type&#x60; parameter
                         *
                         * @method getFolders
                         * @param {String} projectId - Project identifier
                         * @param {String} type - Optional, possible values are &#x60;metric&#x60;, &#x60;fact&#x60;, &#x60;attribute&#x60;
                         * @return {Array} An array of dimension objects
                         */
                        export function getFolders(projectId, type) {
                            function getFolderEntries(pId, t) {
                                const typeURL = t ? &#x60;?type=${t}&#x60; : &#x27;&#x27;;
                        
                                return get(&#x60;/gdc/md/${pId}/query/folders${typeURL}&#x60;).then(getIn(&#x27;query.entries&#x27;));
                            }
                        
                            switch (type) {
                                case &#x27;fact&#x27;:
                                case &#x27;metric&#x27;:
                                    return getFolderEntries(projectId, type);
                                case &#x27;attribute&#x27;:
                                    return getDimensions(projectId);
                                default:
                                    return Promise.all([
                                        getFolderEntries(projectId, &#x27;fact&#x27;),
                                        getFolderEntries(projectId, &#x27;metric&#x27;),
                                        getDimensions(projectId)
                                    ])
                                    .then(([facts, metrics, attributes]) =&gt; {
                                        return { fact: facts, metric: metrics, attribute: attributes };
                                    });
                            }
                        }
                        
                        /**
                         * Returns all facts in a project specified by the given projectId
                         *
                         * @method getFacts
                         * @param {string} projectId Project identifier
                         * @return {Array} An array of fact objects
                         */
                        export function getFacts(projectId) {
                            return get(&#x60;/gdc/md/${projectId}/query/facts&#x60;).then(r =&gt; (r.ok ? r.json() : r)).then(getIn(&#x27;query.entries&#x27;));
                        }
                        
                        /**
                         * Returns all metrics in a project specified by the given projectId
                         *
                         * @method getMetrics
                         * @param {string} projectId Project identifier
                         * @return {Array} An array of metric objects
                         */
                        export function getMetrics(projectId) {
                            return get(&#x60;/gdc/md/${projectId}/query/metrics&#x60;).then(r =&gt; (r.ok ? r.json() : r)).then(getIn(&#x27;query.entries&#x27;));
                        }
                        
                        /**
                         * Returns all metrics that are reachable (with respect to ldm of the project
                         * specified by the given projectId) for given attributes
                         *
                         * @method getAvailableMetrics
                         * @param {String} projectId - Project identifier
                         * @param {Array} attrs - An array of attribute uris for which we want to get
                         * availabale metrics
                         * @return {Array} An array of reachable metrics for the given attrs
                         * @see getAvailableAttributes
                         * @see getAvailableFacts
                         */
                        export function getAvailableMetrics(projectId, attrs) {
                            return post(&#x60;/gdc/md/${projectId}/availablemetrics&#x60;, {
                                data: JSON.stringify(attrs)
                            }).then(r =&gt; (r.ok ? r.json() : r)).then(r =&gt; r.entries);
                        }
                        
                        /**
                         * Returns all attributes that are reachable (with respect to ldm of the project
                         * specified by the given projectId) for given metrics (also called as drillCrossPath)
                         *
                         * @method getAvailableAttributes
                         * @param {String} projectId - Project identifier
                         * @param {Array} metrics - An array of metric uris for which we want to get
                         * availabale attributes
                         * @return {Array} An array of reachable attributes for the given metrics
                         * @see getAvailableMetrics
                         * @see getAvailableFacts
                         */
                        export function getAvailableAttributes(projectId, metrics) {
                            return post(&#x60;/gdc/md/${projectId}/drillcrosspaths&#x60;, {
                                body: JSON.stringify(metrics)
                            }).then(r =&gt; (r.ok ? r.json() : r)).then(r =&gt; r.drillcrosspath.links);
                        }
                        
                        /**
                         * Returns all attributes that are reachable (with respect to ldm of the project
                         * specified by the given projectId) for given metrics (also called as drillCrossPath)
                         *
                         * @method getAvailableFacts
                         * @param {String} projectId - Project identifier
                         * @param {Array} items - An array of metric or attribute uris for which we want to get
                         * availabale facts
                         * @return {Array} An array of reachable facts for the given items
                         * @see getAvailableAttributes
                         * @see getAvailableMetrics
                         */
                        export function getAvailableFacts(projectId, items) {
                            return post(&#x60;/gdc/md/${projectId}/availablefacts&#x60;, {
                                data: JSON.stringify(items)
                            }).then(r =&gt; (r.ok ? r.json() : r)).then(r =&gt; r.entries);
                        }
                        
                        /**
                         * Get details of a metadata object specified by its uri
                         *
                         * @method getObjectDetails
                         * @param uri uri of the metadata object for which details are to be retrieved
                         * @return {Object} object details
                         */
                        export function getObjectDetails(uri) {
                            return get(uri);
                        }
                        
                        /**
                         * Get folders with items.
                         * Returns array of folders, each having a title and items property which is an array of
                         * corresponding items. Each item is either a metric or attribute, keeping its original
                         * verbose structure.
                         *
                         * @method getFoldersWithItems
                         * @param {String} type type of folders to return
                         * @return {Array} Array of folder object, each containing title and
                         * corresponding items.
                         */
                        
                        export function getFoldersWithItems(projectId, type) {
                            // fetch all folders of given type and process them
                            return getFolders(projectId, type).then((folders) =&gt; {
                                // Helper function to get details for each metric in the given
                                // array of links to the metadata objects representing the metrics.
                                // @return the array of promises
                                function getMetricItemsDetails(array) {
                                    return Promise.all(array.map(getObjectDetails)).then((metricArgs) =&gt; {
                                        return metricArgs.map(item =&gt; item.metric);
                                    });
                                }
                        
                                // helper mapBy function
                                function mapBy(array, key) {
                                    return array.map((item) =&gt; {
                                        return item[key];
                                    });
                                }
                        
                                // helper for sorting folder tree structure
                                // sadly @returns void (sorting == mutating array in js)
                                const sortFolderTree = (structure) =&gt; {
                                    structure.forEach((folder) =&gt; {
                                        folder.items.sort((a, b) =&gt; {
                                            if (a.meta.title &lt; b.meta.title) {
                                                return -1;
                                            } else if (a.meta.title &gt; b.meta.title) {
                                                return 1;
                                            }
                        
                                            return 0;
                                        });
                                    });
                                    structure.sort((a, b) =&gt; {
                                        if (a.title &lt; b.title) {
                                            return -1;
                                        } else if (a.title &gt; b.title) {
                                            return 1;
                                        }
                        
                                        return 0;
                                    });
                                };
                        
                                const foldersLinks = mapBy(folders, &#x27;link&#x27;);
                                const foldersTitles = mapBy(folders, &#x27;title&#x27;);
                        
                                // fetch details for each folder
                                return Promise.all(foldersLinks.map(getObjectDetails)).then((folderDetails) =&gt; {
                                    // if attribute, just parse everything from what we&#x27;ve received
                                    // and resolve. For metrics, lookup again each metric to get its
                                    // identifier. If passing unsupported type, reject immediately.
                                    if (type === &#x27;attribute&#x27;) {
                                        // get all attributes, subtract what we have and add rest in unsorted folder
                                        return getAttributes(projectId).then((attributes) =&gt; {
                                            // get uris of attributes which are in some dimension folders
                                            const attributesInFolders = [];
                                            folderDetails.forEach((fd) =&gt; {
                                                fd.dimension.content.attributes.forEach((attr) =&gt; {
                                                    attributesInFolders.push(attr.meta.uri);
                                                });
                                            });
                                            // unsortedUris now contains uris of all attributes which aren&#x27;t in a folder
                                            const unsortedUris =
                                                attributes
                                                    .filter(item =&gt; attributesInFolders.indexOf(item.link) === -1)
                                                    .map(item =&gt; item.link);
                                            // now get details of attributes in no folders
                                            return Promise.all(unsortedUris.map(getObjectDetails))
                                                .then((unsortedAttributeArgs) =&gt; { // TODO add map to r.json
                                                    // get unsorted attribute objects
                                                    const unsortedAttributes = unsortedAttributeArgs.map(attr =&gt; attr.attribute);
                                                    // create structure of folders with attributes
                                                    const structure = folderDetails.map((folderDetail) =&gt; {
                                                        return {
                                                            title: folderDetail.dimension.meta.title,
                                                            items: folderDetail.dimension.content.attributes
                                                        };
                                                    });
                                                    // and append &quot;Unsorted&quot; folder with attributes to the structure
                                                    structure.push({
                                                        title: &#x27;Unsorted&#x27;,
                                                        items: unsortedAttributes
                                                    });
                                                    sortFolderTree(structure);
                        
                                                    return structure;
                                                });
                                        });
                                    } else if (type === &#x27;metric&#x27;) {
                                        const entriesLinks = folderDetails.map(entry =&gt; mapBy(entry.folder.content.entries, &#x27;link&#x27;));
                                        // get all metrics, subtract what we have and add rest in unsorted folder
                                        return getMetrics(projectId).then((metrics) =&gt; {
                                            // get uris of metrics which are in some dimension folders
                                            const metricsInFolders = [];
                                            folderDetails.forEach((fd) =&gt; {
                                                fd.folder.content.entries.forEach((metric) =&gt; {
                                                    metricsInFolders.push(metric.link);
                                                });
                                            });
                                            // unsortedUris now contains uris of all metrics which aren&#x27;t in a folder
                                            const unsortedUris =
                                                metrics
                                                    .filter(item =&gt; metricsInFolders.indexOf(item.link) === -1)
                                                    .map(item =&gt; item.link);
                        
                                            // sadly order of parameters of concat matters! (we want unsorted last)
                                            entriesLinks.push(unsortedUris);
                        
                                            // now get details of all metrics
                                            return Promise.all(entriesLinks.map(linkArray =&gt; getMetricItemsDetails(linkArray)))
                                                .then((tree) =&gt; { // TODO add map to r.json
                                                    // all promises resolved, i.e. details for each metric are available
                                                    const structure = tree.map((treeItems, idx) =&gt; {
                                                        // if idx is not in foldes list than metric is in &quot;Unsorted&quot; folder
                                                        return {
                                                            title: (foldersTitles[idx] || &#x27;Unsorted&#x27;),
                                                            items: treeItems
                                                        };
                                                    });
                                                    sortFolderTree(structure);
                                                    return structure;
                                                });
                                        });
                                    }
                        
                                    return Promise.reject();
                                });
                            });
                        }
                        
                        /**
                         * Get identifier of a metadata object identified by its uri
                         *
                         * @method getObjectIdentifier
                         * @param uri uri of the metadata object for which the identifier is to be retrieved
                         * @return {String} object identifier
                         */
                        export function getObjectIdentifier(uri) {
                            function idFinder(obj) {
                                if (obj.attribute) {
                                    return obj.attribute.content.displayForms[0].meta.identifier;
                                } else if (obj.dimension) {
                                    return obj.dimension.content.attributes.content.displayForms[0].meta.identifier;
                                } else if (obj.metric) {
                                    return obj.metric.meta.identifier;
                                }
                        
                                throw Error(&#x27;Unknown object!&#x27;);
                            }
                        
                            if (!isPlainObject(uri)) {
                                return getObjectDetails(uri).then(data =&gt; idFinder(data));
                            }
                            return Promise.resolve(idFinder(uri));
                        }
                        
                        /**
                         * Get uri of an metadata object, specified by its identifier and project id it belongs to
                         *
                         * @method getObjectUri
                         * @param {string} projectId id of the project
                         * @param identifier identifier of the metadata object
                         * @return {String} uri of the metadata object
                         */
                        export function getObjectUri(projectId, identifier) {
                            return ajax(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                method: &#x27;POST&#x27;,
                                body: {
                                    identifierToUri: [identifier]
                                }
                            }).then(parseJSON).then((data) =&gt; {
                                const found = data.identifiers.find(pair =&gt; pair.identifier === identifier);
                        
                                if (found) {
                                    return found.uri;
                                }
                        
                                throw new Error(&#x60;Object with identifier ${identifier} not found in project ${projectId}&#x60;);
                            });
                        }
                        
                        /**
                         * Get uris specified by identifiers
                         *
                         * @method getUrisFromIdentifiers
                         * @param {String} projectId id of the project
                         * @param {Array} identifiers identifiers of the metadata objects
                         * @return {Array} array of identifier + uri pairs
                         */
                        export function getUrisFromIdentifiers(projectId, identifiers) {
                            return post(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                body: {
                                    identifierToUri: identifiers
                                }
                            }).then(parseJSON).then((data) =&gt; {
                                return data.identifiers;
                            });
                        }
                        
                        /**
                         * Get identifiers specified by uris
                         *
                         * @method getIdentifiersFromUris
                         * @param {String} projectId id of the project
                         * @param {Array} uris of the metadata objects
                         * @return {Array} array of identifier + uri pairs
                         */
                        export function getIdentifiersFromUris(projectId, uris) {
                            return post(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                body: {
                                    uriToIdentifier: uris
                                }
                            }).then(parseJSON).then((data) =&gt; {
                                return data.identifiers;
                            });
                        }
                        
                        /**
                         * Get attribute elements with their labels and uris.
                         *
                         * @param {String} projectId id of the project
                         * @param {String} labelUri uri of the label (display form)
                         * @param {Array&lt;String&gt;} patterns elements labels/titles (for EXACT mode), or patterns (for WILD mode)
                         * @param {(&#x27;EXACT&#x27;|&#x27;WILD&#x27;)} mode match mode, currently only EXACT supported
                         * @return {Array} array of elementLabelUri objects
                         */
                        export function translateElementLabelsToUris(projectId, labelUri, patterns, mode = &#x27;EXACT&#x27;) {
                            return post(&#x60;/gdc/md/${projectId}/labels&#x60;, {
                                body: {
                                    elementLabelToUri: [
                                        {
                                            labelUri,
                                            mode,
                                            patterns
                                        }
                                    ]
                                }
                            }).then(r =&gt; (r.ok ? r.json() : r)).then(r =&gt; _get(r, &#x27;elementLabelUri&#x27;));
                        }
                        
                        /**
                         * Get valid elements of an attribute, specified by its identifier and project id it belongs to
                         *
                         * @method getValidElements
                         * @param {string} projectId id of the project
                         * @param id display form identifier of the metadata object
                         * @param {Object} options objects with options:
                         *      - limit {Number}
                         *      - offset {Number}
                         *      - order {String} &#x27;asc&#x27; or &#x27;desc&#x27;
                         *      - filter {String}
                         *      - prompt {String}
                         *      - uris {Array}
                         *      - complement {Boolean}
                         *      - includeTotalCountWithoutFilters {Boolean}
                         *      - restrictiveDefinition {String}
                         * @return {Object} ValidElements response with:
                         *      - items {Array} elements
                         *      - paging {Object}
                         *      - elementsMeta {Object}
                         */
                        export function getValidElements(projectId, id, options = {}) {
                            const query = pick(options, [&#x27;limit&#x27;, &#x27;offset&#x27;, &#x27;order&#x27;, &#x27;filter&#x27;, &#x27;prompt&#x27;]);
                            const queryParams = queryString(query);
                        
                            const requestBody = pick(options, [&#x27;uris&#x27;, &#x27;complement&#x27;, &#x27;includeTotalCountWithoutFilters&#x27;, &#x27;restrictiveDefinition&#x27;]);
                            return post(&#x60;/gdc/md/${projectId}/obj/${id}/validElements${queryParams}&#x60;.replace(/\?$/, &#x27;&#x27;), {
                                data: JSON.stringify({
                                    validElementsRequest: requestBody
                                })
                            }).then(parseJSON);
                        }
                        
                        /**
                         * Delete object
                         *
                         * @experimental
                         * @method deleteObject
                         * @param {String} uri of the object to be deleted
                         */
                        export function deleteObject(uri) {
                            return del(uri);
                        }
                        
                        /**
                         * Create object
                         *
                         * @experimental
                         * @method createObject
                         * @param {String} projectId
                         * @param {String} obj object definition
                         */
                        export function createObject(projectId, obj) {
                            return post(&#x60;/gdc/md/${projectId}/obj?createAndGet=true&#x60;, {
                                data: JSON.stringify(obj)
                            }).then(parseJSON);
                        }
                        
                        function isTaskFinished(task) {
                            const taskState = task.wTaskStatus.status;
                            return taskState === &#x27;OK&#x27; || taskState === &#x27;ERROR&#x27;;
                        }
                        
                        function checkStatusForError(response) {
                            if (response.wTaskStatus.status === &#x27;ERROR&#x27;) {
                                return Promise.reject(response);
                            }
                            return response;
                        }
                        
                        /**
                         * LDM manage
                         *
                         * @experimental
                         * @method ldmManage
                         * @param {String} projectId
                         * @param {String} maql
                         * @param {Object} options for polling (maxAttempts, pollStep)
                         */
                        export function ldmManage(projectId, maql, options = {}) {
                            return post(&#x60;/gdc/md/${projectId}/ldm/manage2&#x60;, {
                                data: JSON.stringify({
                                    manage: { maql }
                                })
                            })
                            .then(parseJSON)
                            .then((response) =&gt; {
                                const manageStatusUri = response.entries[0].link;
                                return handlePolling(manageStatusUri, isTaskFinished, options);
                            })
                            .then(checkStatusForError);
                        }
                        
                        /**
                         * ETL pull
                         *
                         * @experimental
                         * @method etlPull
                         * @param {String} projectId
                         * @param {String} uploadsDir
                         * @param {Object} options for polling (maxAttempts, pollStep)
                         */
                        export function etlPull(projectId, uploadsDir, options = {}) {
                            return post(&#x60;/gdc/md/${projectId}/etl/pull2&#x60;, {
                                data: JSON.stringify({
                                    pullIntegration: uploadsDir
                                })
                            })
                            .then(parseJSON)
                            .then((response) =&gt; {
                                const etlPullStatusUri = response.pull2Task.links.poll;
                                return handlePolling(etlPullStatusUri, isTaskFinished, options);
                            })
                            .then(checkStatusForError);
                        }
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

