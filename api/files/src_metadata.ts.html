---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/DataLayer.html">DataLayer</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/report.html">report</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/DataLayer.html">DataLayer</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/report.html">report</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v13.5.0</span>
                        <h1 class="file-heading">File: src/metadata.ts</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // (C) 2007-2020 GoodData Corporation
                        import isPlainObject from &quot;lodash/isPlainObject&quot;;
                        import get from &quot;lodash/get&quot;;
                        import chunk from &quot;lodash/chunk&quot;;
                        import flatten from &quot;lodash/flatten&quot;;
                        import pick from &quot;lodash/pick&quot;;
                        import { AFM, VisualizationObject } from &quot;@gooddata/typings&quot;;
                        import { getIn, handlePolling, queryString } from &quot;./util&quot;;
                        import { ApiResponse, ApiResponseError, XhrModule } from &quot;./xhr&quot;;
                        import { IGetObjectsByQueryOptions, IGetObjectUsingOptions, SortDirection } from &quot;./interfaces&quot;;
                        import { convertUrisToReferences, convertReferencesToUris } from &quot;./referenceHandling&quot;;
                        import { convertAfm } from &quot;./execution/execute-afm.convert&quot;;
                        
                        export interface IValidElementsOptions {
                            limit?: number;
                            offset?: number;
                            order?: SortDirection;
                            filter?: string;
                            prompt?: string;
                            uris?: string[];
                            complement?: boolean;
                            includeTotalCountWithoutFilters?: boolean;
                            restrictiveDefinition?: string;
                            restrictiveDefinitionContent?: object;
                            afm?: AFM.IAfm;
                        }
                        
                        /**
                         * Functions for working with metadata objects
                         *
                         * @class metadata
                         * @module metadata
                         */
                        export class MetadataModule {
                            constructor(private xhr: XhrModule) {}
                        
                            /**
                             * Load all objects with given uris
                             * (use bulk loading instead of getting objects one by one)
                             *
                             * @method getObjects
                             * @param {String} projectId id of the project
                             * @param {Array} objectUris array of uris for objects to be loaded
                             * @return {Array} array of loaded elements
                             */
                            public getObjects(projectId: string, objectUris: string[]): any {
                                const LIMIT = 50;
                                const uri = &#x60;/gdc/md/${projectId}/objects/get&#x60;;
                        
                                const objectsUrisChunks = chunk(objectUris, LIMIT);
                        
                                const promises = objectsUrisChunks.map(objectUrisChunk =&gt; {
                                    const body = {
                                        get: {
                                            items: objectUrisChunk,
                                        },
                                    };
                        
                                    return this.xhr
                                        .post(uri, { body })
                                        .then((r: ApiResponse) =&gt; {
                                            if (!r.response.ok) {
                                                throw new ApiResponseError(r.response.statusText, r.response, r.responseBody);
                                            }
                        
                                            return r.getData();
                                        })
                                        .then((result: any) =&gt;
                                            get(result, [&quot;objects&quot;, &quot;items&quot;]).map((item: any) =&gt; {
                                                if (item.visualizationObject) {
                                                    return {
                                                        visualizationObject: convertReferencesToUris(item.visualizationObject),
                                                    };
                                                }
                                                if (item.visualizationWidget) {
                                                    return {
                                                        visualizationWidget: convertReferencesToUris(item.visualizationWidget),
                                                    };
                                                }
                                                return item;
                                            }),
                                        );
                                });
                        
                                return Promise.all(promises).then(flatten);
                            }
                        
                            /**
                             * Loads all objects by query (fetches all pages, one by one)
                             *
                             * @method getObjectsByQuery
                             * @param {String} projectId id of the project
                             * @param {Object} options (see https://developer.gooddata.com/api endpoint: /gdc/md/{project_id}/objects/query)
                             *        - category {String} for example &#x27;dataSets&#x27; or &#x27;projectDashboard&#x27;
                             *        - mode {String} &#x27;enriched&#x27; or &#x27;raw&#x27;
                             *        - author {String} the URI of the author of the metadata objects
                             *        - limit {number} default is 50 (also maximum)
                             *        - deprecated {boolean} show also deprecated objects
                             * @return {Promise&lt;Array&gt;} array of returned objects
                             */
                            public getObjectsByQuery(projectId: string, options: IGetObjectsByQueryOptions): Promise&lt;any[]&gt; {
                                const getOnePage = (uri: string, items: any[] = []): Promise&lt;any&gt; =&gt; {
                                    return this.xhr
                                        .get(uri)
                                        .then((r: ApiResponse) =&gt; r.getData())
                                        .then(({ objects }: any) =&gt; {
                                            items.push(...objects.items);
                                            const nextUri = objects.paging.next;
                                            return nextUri ? getOnePage(nextUri, items) : items;
                                        });
                                };
                        
                                const deprecated = options.deprecated ? { deprecated: 1 } : {};
                                const uri = &#x60;/gdc/md/${projectId}/objects/query&#x60;;
                                const query = pick({ limit: 50, ...options, ...deprecated }, [
                                    &quot;category&quot;,
                                    &quot;mode&quot;,
                                    &quot;author&quot;,
                                    &quot;limit&quot;,
                                    &quot;deprecated&quot;,
                                ]);
                                return getOnePage(uri + queryString(query));
                            }
                        
                            /**
                             * Get MD objects from using2 resource. Include only objects of given types
                             * and take care about fetching only nearest objects if requested.
                             *
                             * @method getObjectUsing
                             * @param {String} projectId id of the project
                             * @param {String} uri uri of the object for which dependencies are to be found
                             * @param {Object} options objects with options:
                             *        - types {Array} array of strings with object types to be included
                             *        - nearest {Boolean} whether to include only nearest dependencies
                             * @return {jQuery promise} promise promise once resolved returns an array of
                             *         entries returned by using2 resource
                             */
                            public getObjectUsing(projectId: string, uri: string, options: IGetObjectUsingOptions = {}) {
                                const { types = [], nearest = false } = options;
                                const resourceUri = &#x60;/gdc/md/${projectId}/using2&#x60;;
                        
                                const body = {
                                    inUse: {
                                        uri,
                                        types,
                                        nearest: nearest ? 1 : 0,
                                    },
                                };
                        
                                return this.xhr
                                    .post(resourceUri, { body })
                                    .then((r: ApiResponse) =&gt; {
                                        if (!r.response.ok) {
                                            throw new ApiResponseError(r.response.statusText, r.response, r.getData());
                                        }
                        
                                        return r.getData();
                                    })
                                    .then((result: any) =&gt; result.entries);
                            }
                        
                            /**
                             * Get MD objects from using2 resource. Include only objects of given types
                             * and take care about fetching only nearest objects if requested.
                             *
                             * @method getObjectUsingMany
                             * @param {String} projectId id of the project
                             * @param {Array} uris uris of objects for which dependencies are to be found
                             * @param {Object} options objects with options:
                             *        - types {Array} array of strings with object types to be included
                             *        - nearest {Boolean} whether to include only nearest dependencies
                             * @return {jQuery promise} promise promise once resolved returns an array of
                             *         entries returned by using2 resource
                             */
                            public getObjectUsingMany(
                                projectId: string,
                                uris: string[],
                                options: IGetObjectUsingOptions = {},
                            ): Promise&lt;any&gt; {
                                const { types = [], nearest = false } = options;
                                const resourceUri = &#x60;/gdc/md/${projectId}/using2&#x60;;
                        
                                const body = {
                                    inUseMany: {
                                        uris,
                                        types,
                                        nearest: nearest ? 1 : 0,
                                    },
                                };
                        
                                return this.xhr
                                    .post(resourceUri, { body })
                                    .then((r: ApiResponse) =&gt; {
                                        if (!r.response.ok) {
                                            throw new ApiResponseError(r.response.statusText, r.response, r.getData());
                                        }
                        
                                        return r.getData();
                                    })
                                    .then((result: any) =&gt; result.useMany);
                            }
                        
                            /**
                             * Returns all visualizationObjects metadata in a project specified by projectId param
                             *
                             * @method getVisualizations
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of visualization objects metadata
                             */
                            public getVisualizations(projectId: string): Promise&lt;any&gt; {
                                return this.xhr
                                    .get(&#x60;/gdc/md/${projectId}/query/visualizationobjects&#x60;)
                                    .then((apiResponse: ApiResponse) =&gt;
                                        apiResponse.response.ok ? apiResponse.getData() : apiResponse.response,
                                    )
                                    .then(getIn(&quot;query.entries&quot;));
                            }
                        
                            /**
                             * Returns all attributes in a project specified by projectId param
                             *
                             * @method getAttributes
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of attribute objects
                             */
                            public getAttributes(projectId: string): Promise&lt;any&gt; {
                                return this.xhr
                                    .get(&#x60;/gdc/md/${projectId}/query/attributes&#x60;)
                                    .then((apiResponse: ApiResponse) =&gt;
                                        apiResponse.response.ok ? apiResponse.getData() : apiResponse.response,
                                    )
                                    .then(getIn(&quot;query.entries&quot;));
                            }
                        
                            /**
                             * Returns all dimensions in a project specified by projectId param
                             *
                             * @method getDimensions
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of dimension objects
                             * @see getFolders
                             */
                            public getDimensions(projectId: string): Promise&lt;any&gt; {
                                return this.xhr
                                    .get(&#x60;/gdc/md/${projectId}/query/dimensions&#x60;)
                                    .then((apiResponse: ApiResponse) =&gt;
                                        apiResponse.response.ok ? apiResponse.getData() : apiResponse.response,
                                    )
                                    .then(getIn(&quot;query.entries&quot;));
                            }
                        
                            /**
                             * Returns project folders. Folders can be of specific types and you can specify
                             * the type you need by passing and optional &#x60;type&#x60; parameter
                             *
                             * @method getFolders
                             * @param {String} projectId - Project identifier
                             * @param {String} type - Optional, possible values are &#x60;metric&#x60;, &#x60;fact&#x60;, &#x60;attribute&#x60;
                             * @return {Array} An array of dimension objects
                             */
                            public getFolders(projectId: string, type: string) {
                                // TODO enum?
                                const getFolderEntries = (pId: string, t: string) =&gt; {
                                    const typeURL = t ? &#x60;?type=${t}&#x60; : &quot;&quot;;
                        
                                    return this.xhr
                                        .get(&#x60;/gdc/md/${pId}/query/folders${typeURL}&#x60;)
                                        .then(r =&gt; r.getData())
                                        .then(getIn(&quot;query.entries&quot;));
                                };
                        
                                switch (type) {
                                    case &quot;fact&quot;:
                                    case &quot;metric&quot;:
                                        return getFolderEntries(projectId, type);
                                    case &quot;attribute&quot;:
                                        return this.getDimensions(projectId);
                                    default:
                                        return Promise.all([
                                            getFolderEntries(projectId, &quot;fact&quot;),
                                            getFolderEntries(projectId, &quot;metric&quot;),
                                            this.getDimensions(projectId),
                                        ]).then(([fact, metric, attribute]) =&gt; {
                                            return { fact, metric, attribute };
                                        });
                                }
                            }
                        
                            /**
                             * Returns all facts in a project specified by the given projectId
                             *
                             * @method getFacts
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of fact objects
                             */
                            public getFacts(projectId: string): Promise&lt;any&gt; {
                                return this.xhr
                                    .get(&#x60;/gdc/md/${projectId}/query/facts&#x60;)
                                    .then((apiResponse: ApiResponse) =&gt;
                                        apiResponse.response.ok ? apiResponse.getData() : apiResponse.response,
                                    )
                                    .then(getIn(&quot;query.entries&quot;));
                            }
                        
                            /**
                             * Returns all metrics in a project specified by the given projectId
                             *
                             * @method getMetrics
                             * @param {string} projectId Project identifier
                             * @return {Array} An array of metric objects
                             */
                            public getMetrics(projectId: string): Promise&lt;any&gt; {
                                return this.xhr
                                    .get(&#x60;/gdc/md/${projectId}/query/metrics&#x60;)
                                    .then((apiResponse: ApiResponse) =&gt;
                                        apiResponse.response.ok ? apiResponse.getData() : apiResponse.response,
                                    )
                                    .then(getIn(&quot;query.entries&quot;));
                            }
                        
                            /**
                             * Returns all metrics that are reachable (with respect to ldm of the project
                             * specified by the given projectId) for given attributes
                             *
                             * @method getAvailableMetrics
                             * @param {String} projectId - Project identifier
                             * @param {Array} attrs - An array of attribute uris for which we want to get
                             * available metrics
                             * @return {Array} An array of reachable metrics for the given attrs
                             * @see getAvailableAttributes
                             * @see getAvailableFacts
                             */
                            public getAvailableMetrics(projectId: string, attrs: string[] = []): Promise&lt;any&gt; {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/availablemetrics&#x60;, { body: attrs })
                                    .then((apiResponse: ApiResponse) =&gt;
                                        apiResponse.response.ok ? apiResponse.getData() : apiResponse.response,
                                    )
                                    .then((data: any) =&gt; data.entries);
                            }
                        
                            /**
                             * Returns all attributes that are reachable (with respect to ldm of the project
                             * specified by the given projectId) for given metrics (also called as drillCrossPath)
                             *
                             * @method getAvailableAttributes
                             * @param {String} projectId - Project identifier
                             * @param {Array} metrics - An array of metric uris for which we want to get
                             * available attributes
                             * @return {Array} An array of reachable attributes for the given metrics
                             * @see getAvailableMetrics
                             * @see getAvailableFacts
                             */
                            public getAvailableAttributes(projectId: string, metrics: string[] = []): Promise&lt;any&gt; {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/drillcrosspaths&#x60;, { body: metrics })
                                    .then(apiResponse =&gt; (apiResponse.response.ok ? apiResponse.getData() : apiResponse.response))
                                    .then((r: any) =&gt; r.drillcrosspath.links);
                            }
                        
                            /**
                             * Returns all attributes that are reachable (with respect to ldm of the project
                             * specified by the given projectId) for given metrics (also called as drillCrossPath)
                             *
                             * @method getAvailableFacts
                             * @param {String} projectId - Project identifier
                             * @param {Array} items - An array of metric or attribute uris for which we want to get
                             * available facts
                             * @return {Array} An array of reachable facts for the given items
                             * @see getAvailableAttributes
                             * @see getAvailableMetrics
                             */
                            public getAvailableFacts(projectId: string, items: string[] = []): Promise&lt;any&gt; {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/availablefacts&#x60;, { body: items })
                                    .then((r: ApiResponse) =&gt; (r.response.ok ? r.getData() : r.response))
                                    .then((r: any) =&gt; r.entries);
                            }
                        
                            /**
                             * Get details of a metadata object specified by its uri
                             *
                             * @method getObjectDetails
                             * @param uri uri of the metadata object for which details are to be retrieved
                             * @return {Object} object details
                             */
                            public getObjectDetails(uri: string): Promise&lt;any&gt; {
                                return this.xhr.get(uri).then((r: ApiResponse) =&gt; r.getData());
                            }
                        
                            /**
                             * Get folders with items.
                             * Returns array of folders, each having a title and items property which is an array of
                             * corresponding items. Each item is either a metric or attribute, keeping its original
                             * verbose structure.
                             *
                             * @method getFoldersWithItems
                             * @param {String} type type of folders to return
                             * @return {Array} Array of folder object, each containing title and
                             * corresponding items.
                             */
                            public getFoldersWithItems(projectId: string, type: string) {
                                // fetch all folders of given type and process them
                                return this.getFolders(projectId, type).then(folders =&gt; {
                                    // Helper public to get details for each metric in the given
                                    // array of links to the metadata objects representing the metrics.
                                    // @return the array of promises
                                    const getMetricItemsDetails = (array: any[]) =&gt; {
                                        return Promise.all(array.map(this.getObjectDetails)).then(metricArgs =&gt; {
                                            return metricArgs.map((item: any) =&gt; item.metric);
                                        });
                                    };
                        
                                    // helper mapBy function
                                    function mapBy(array: any[], key: string) {
                                        return array.map((item: any) =&gt; {
                                            return item[key];
                                        });
                                    }
                        
                                    // helper for sorting folder tree structure
                                    // sadly @returns void (sorting == mutating array in js)
                                    const sortFolderTree = (structure: any[]) =&gt; {
                                        structure.forEach(folder =&gt; {
                                            folder.items.sort((a: any, b: any) =&gt; {
                                                if (a.meta.title &lt; b.meta.title) {
                                                    return -1;
                                                } else if (a.meta.title &gt; b.meta.title) {
                                                    return 1;
                                                }
                        
                                                return 0;
                                            });
                                        });
                                        structure.sort((a, b) =&gt; {
                                            if (a.title &lt; b.title) {
                                                return -1;
                                            } else if (a.title &gt; b.title) {
                                                return 1;
                                            }
                        
                                            return 0;
                                        });
                                    };
                        
                                    const foldersLinks = mapBy(folders, &quot;link&quot;);
                                    const foldersTitles = mapBy(folders, &quot;title&quot;);
                        
                                    // fetch details for each folder
                                    return Promise.all(foldersLinks.map(this.getObjectDetails)).then(folderDetails =&gt; {
                                        // if attribute, just parse everything from what we&#x27;ve received
                                        // and resolve. For metrics, lookup again each metric to get its
                                        // identifier. If passing unsupported type, reject immediately.
                                        if (type === &quot;attribute&quot;) {
                                            // get all attributes, subtract what we have and add rest in unsorted folder
                                            return this.getAttributes(projectId).then(attributes =&gt; {
                                                // get uris of attributes which are in some dimension folders
                                                const attributesInFolders: any[] = [];
                                                folderDetails.forEach((fd: any) =&gt; {
                                                    fd.dimension.content.attributes.forEach((attr: any) =&gt; {
                                                        attributesInFolders.push(attr.meta.uri);
                                                    });
                                                });
                                                // unsortedUris now contains uris of all attributes which aren&#x27;t in a folder
                                                const unsortedUris = attributes
                                                    .filter((item: any) =&gt; attributesInFolders.indexOf(item.link) === -1)
                                                    .map((item: any) =&gt; item.link);
                                                // now get details of attributes in no folders
                                                return Promise.all(unsortedUris.map(this.getObjectDetails)).then(
                                                    unsortedAttributeArgs =&gt; {
                                                        // TODO add map to r.json
                                                        // get unsorted attribute objects
                                                        const unsortedAttributes = unsortedAttributeArgs.map(
                                                            (attr: any) =&gt; attr.attribute,
                                                        );
                                                        // create structure of folders with attributes
                                                        const structure = folderDetails.map((folderDetail: any) =&gt; {
                                                            return {
                                                                title: folderDetail.dimension.meta.title,
                                                                items: folderDetail.dimension.content.attributes,
                                                            };
                                                        });
                                                        // and append &quot;Unsorted&quot; folder with attributes to the structure
                                                        structure.push({
                                                            title: &quot;Unsorted&quot;,
                                                            items: unsortedAttributes,
                                                        });
                                                        sortFolderTree(structure);
                        
                                                        return structure;
                                                    },
                                                );
                                            });
                                        } else if (type === &quot;metric&quot;) {
                                            const entriesLinks = folderDetails.map((entry: any) =&gt;
                                                mapBy(entry.folder.content.entries, &quot;link&quot;),
                                            );
                                            // get all metrics, subtract what we have and add rest in unsorted folder
                                            return this.getMetrics(projectId).then(metrics =&gt; {
                                                // get uris of metrics which are in some dimension folders
                                                const metricsInFolders: string[] = [];
                                                folderDetails.forEach((fd: any) =&gt; {
                                                    fd.folder.content.entries.forEach((metric: any) =&gt; {
                                                        metricsInFolders.push(metric.link);
                                                    });
                                                });
                                                // unsortedUris now contains uris of all metrics which aren&#x27;t in a folder
                                                const unsortedUris = metrics
                                                    .filter((item: any) =&gt; metricsInFolders.indexOf(item.link) === -1)
                                                    .map((item: any) =&gt; item.link);
                        
                                                // sadly order of parameters of concat matters! (we want unsorted last)
                                                entriesLinks.push(unsortedUris);
                        
                                                // now get details of all metrics
                                                return Promise.all(
                                                    entriesLinks.map(linkArray =&gt; getMetricItemsDetails(linkArray)),
                                                ).then(tree =&gt; {
                                                    // TODO add map to r.json
                                                    // all promises resolved, i.e. details for each metric are available
                                                    const structure = tree.map((treeItems, idx) =&gt; {
                                                        // if idx is not in folders list than metric is in &quot;Unsorted&quot; folder
                                                        return {
                                                            title: foldersTitles[idx] || &quot;Unsorted&quot;,
                                                            items: treeItems,
                                                        };
                                                    });
                                                    sortFolderTree(structure);
                                                    return structure;
                                                });
                                            });
                                        }
                        
                                        return Promise.reject(null);
                                    });
                                });
                            }
                        
                            /**
                             * Get identifier of a metadata object identified by its uri
                             *
                             * @method getObjectIdentifier
                             * @param uri uri of the metadata object for which the identifier is to be retrieved
                             * @return {String} object identifier
                             */
                            public getObjectIdentifier(uri: string) {
                                function idFinder(obj: any) {
                                    // TODO
                                    if (obj.attribute) {
                                        return obj.attribute.content.displayForms[0].meta.identifier;
                                    } else if (obj.dimension) {
                                        return obj.dimension.content.attributes.content.displayForms[0].meta.identifier;
                                    } else if (obj.metric) {
                                        return obj.metric.meta.identifier;
                                    }
                        
                                    throw Error(&quot;Unknown object!&quot;);
                                }
                        
                                if (!isPlainObject(uri)) {
                                    return this.getObjectDetails(uri).then(data =&gt; idFinder(data));
                                }
                                return Promise.resolve(idFinder(uri));
                            }
                        
                            /**
                             * Get uri of an metadata object, specified by its identifier and project id it belongs to
                             *
                             * @method getObjectUri
                             * @param {string} projectId id of the project
                             * @param identifier identifier of the metadata object
                             * @return {String} uri of the metadata object
                             */
                            public getObjectUri(projectId: string, identifier: string) {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                        body: {
                                            identifierToUri: [identifier],
                                        },
                                    })
                                    .then((r: ApiResponse) =&gt; {
                                        const data = r.getData();
                                        const found = data.identifiers.find((pair: any) =&gt; pair.identifier === identifier);
                        
                                        if (found) {
                                            return found.uri;
                                        }
                        
                                        throw new ApiResponseError(
                                            &#x60;Object with identifier ${identifier} not found in project ${projectId}&#x60;,
                                            r.response,
                                            r.responseBody,
                                        );
                                    });
                            }
                        
                            /**
                             * Get uris specified by identifiers
                             *
                             * @method getUrisFromIdentifiers
                             * @param {String} projectId id of the project
                             * @param {Array} identifiers identifiers of the metadata objects
                             * @return {Array} array of identifier + uri pairs
                             */
                            public getUrisFromIdentifiers(projectId: string, identifiers: string[]) {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                        body: {
                                            identifierToUri: identifiers,
                                        },
                                    })
                                    .then((r: ApiResponse) =&gt; r.getData())
                                    .then(data =&gt; {
                                        return data.identifiers;
                                    });
                            }
                        
                            /**
                             * Get identifiers specified by uris
                             *
                             * @method getIdentifiersFromUris
                             * @param {String} projectId id of the project
                             * @param {Array} uris of the metadata objects
                             * @return {Array} array of identifier + uri pairs
                             */
                            public getIdentifiersFromUris(projectId: string, uris: string[]) {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/identifiers&#x60;, {
                                        body: {
                                            uriToIdentifier: uris,
                                        },
                                    })
                                    .then((r: ApiResponse) =&gt; r.getData())
                                    .then(data =&gt; {
                                        return data.identifiers;
                                    });
                            }
                        
                            /**
                             * Get attribute elements with their labels and uris.
                             *
                             * @param {String} projectId id of the project
                             * @param {String} labelUri uri of the label (display form)
                             * @param {Array&lt;String&gt;} patterns elements labels/titles (for EXACT mode), or patterns (for WILD mode)
                             * @param {(&#x27;EXACT&#x27;|&#x27;WILD&#x27;)} mode match mode, currently only EXACT supported
                             * @return {Array} array of elementLabelUri objects
                             */
                            public translateElementLabelsToUris(
                                projectId: string,
                                labelUri: string,
                                patterns: string[],
                                mode = &quot;EXACT&quot;,
                            ) {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/labels&#x60;, {
                                        body: {
                                            elementLabelToUri: [
                                                {
                                                    labelUri,
                                                    mode,
                                                    patterns,
                                                },
                                            ],
                                        },
                                    })
                                    .then((r: ApiResponse) =&gt; (r.response.ok ? get(r.getData(), &quot;elementLabelUri&quot;) : r.response));
                            }
                        
                            /**
                             * Get valid elements of an attribute, specified by its identifier and project id it belongs to
                             *
                             * @method getValidElements
                             * @param {string} projectId id of the project
                             * @param id display form id of the metadata object
                             * @param {Object} options objects with options:
                             *      - limit {Number}
                             *      - offset {Number}
                             *      - order {String} &#x27;asc&#x27; or &#x27;desc&#x27;
                             *      - filter {String}
                             *      - prompt {String}
                             *      - uris {Array}
                             *      - complement {Boolean}
                             *      - includeTotalCountWithoutFilters {Boolean}
                             *      - restrictiveDefinition {String}
                             *      - afm {Object}
                             * @return {Object} ValidElements response with:
                             *      - items {Array} elements
                             *      - paging {Object}
                             *      - elementsMeta {Object}
                             */
                            public getValidElements(projectId: string, id: string, options: IValidElementsOptions = {}) {
                                const query = pick(options, [&quot;limit&quot;, &quot;offset&quot;, &quot;order&quot;, &quot;filter&quot;, &quot;prompt&quot;]);
                                const queryParams = queryString(query);
                                const pickedOptions = pick(options, [
                                    &quot;uris&quot;,
                                    &quot;complement&quot;,
                                    &quot;includeTotalCountWithoutFilters&quot;,
                                    &quot;restrictiveDefinition&quot;,
                                ]);
                                const { afm } = options;
                        
                                const getRequestBodyWithReportDefinition = () =&gt;
                                    this.xhr
                                        .post(&#x60;/gdc/app/projects/${projectId}/executeAfm/debug&#x60;, {
                                            body: {
                                                execution: {
                                                    afm: convertAfm(afm),
                                                },
                                            },
                                        })
                                        .then(response =&gt; response.getData())
                                        .then(reportDefinitionResult =&gt; ({
                                            ...pickedOptions,
                                            restrictiveDefinitionContent:
                                                reportDefinitionResult.reportDefinitionWithInlinedMetrics.content,
                                        }));
                        
                                const getOptions = afm ? getRequestBodyWithReportDefinition : () =&gt; Promise.resolve(pickedOptions);
                        
                                return getOptions().then(requestBody =&gt;
                                    this.xhr
                                        .post(&#x60;/gdc/md/${projectId}/obj/${id}/validElements${queryParams}&#x60;.replace(/\?$/, &quot;&quot;), {
                                            body: {
                                                validElementsRequest: requestBody,
                                            },
                                        })
                                        .then(response =&gt; response.getData()),
                                );
                            }
                        
                            /**
                             * Get visualization by Uri and process data
                             *
                             * @method getVisualization
                             * @param {String} visualizationUri
                             */
                            public getVisualization(uri: string): Promise&lt;VisualizationObject.IVisualization&gt; {
                                return this.getObjectDetails(uri).then(
                                    (visualizationObject: VisualizationObject.IVisualizationObjectResponse) =&gt; {
                                        const mdObject = visualizationObject.visualizationObject;
                                        return {
                                            visualizationObject: convertReferencesToUris(
                                                mdObject,
                                            ) as VisualizationObject.IVisualizationObject,
                                        };
                                    },
                                );
                            }
                        
                            /**
                             * Save visualization
                             *
                             * @method saveVisualization
                             * @param {String} visualizationUri
                             */
                            public saveVisualization(projectId: string, visualization: VisualizationObject.IVisualization) {
                                const converted = convertUrisToReferences(visualization.visualizationObject);
                                return this.createObject(projectId, { visualizationObject: converted });
                            }
                        
                            /**
                             * Update visualization
                             *
                             * @method updateVisualization
                             * @param {String} visualizationUri
                             */
                            public updateVisualization(
                                projectId: string,
                                visualizationUri: string,
                                visualization: VisualizationObject.IVisualization,
                            ) {
                                const converted = convertUrisToReferences(visualization.visualizationObject);
                                return this.updateObject(projectId, visualizationUri, { visualizationObject: converted });
                            }
                        
                            /**
                             * Delete visualization
                             *
                             * @method deleteVisualization
                             * @param {String} visualizationUri
                             */
                            public deleteVisualization(visualizationUri: string) {
                                return this.deleteObject(visualizationUri);
                            }
                        
                            /**
                             * Delete object
                             *
                             * @experimental
                             * @method deleteObject
                             * @param {String} uri of the object to be deleted
                             */
                            public deleteObject(uri: string) {
                                return this.xhr.del(uri);
                            }
                        
                            /**
                             * Create object
                             *
                             * @experimental
                             * @method createObject
                             * @param {String} projectId
                             * @param {String} obj object definition
                             */
                            public createObject(projectId: string, obj: any) {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/obj?createAndGet=true&#x60;, {
                                        body: obj,
                                    })
                                    .then((r: ApiResponse) =&gt; r.getData());
                            }
                        
                            /**
                             * Update object
                             *
                             * @experimental
                             * @method updateObject
                             * @param {String} projectId
                             * @param {String} visualizationUri
                             * @param {String} obj object definition
                             */
                            public updateObject(projectId: string, visualizationUri: string, obj: any) {
                                return this.xhr
                                    .put(&#x60;/gdc/md/${projectId}/obj/${visualizationUri}&#x60;, {
                                        body: obj,
                                    })
                                    .then((r: ApiResponse) =&gt; r.getData());
                            }
                        
                            /**
                             * LDM manage
                             *
                             * @experimental
                             * @method ldmManage
                             * @param {String} projectId
                             * @param {String} maql
                             * @param {Object} options for polling (maxAttempts, pollStep)
                             */
                            public ldmManage(projectId: string, maql: string, options = {}) {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/ldm/manage2&#x60;, { body: { manage: { maql } } })
                                    .then((r: ApiResponse) =&gt; r.getData())
                                    .then((response: any) =&gt; {
                                        const manageStatusUri = response.entries[0].link;
                                        return handlePolling(
                                            this.xhr.get.bind(this.xhr),
                                            manageStatusUri,
                                            this.isTaskFinished,
                                            options,
                                        );
                                    })
                                    .then(this.checkStatusForError);
                            }
                        
                            /**
                             * ETL pull
                             *
                             * @experimental
                             * @method etlPull
                             * @param {String} projectId
                             * @param {String} uploadsDir
                             * @param {Object} options for polling (maxAttempts, pollStep)
                             */
                            public etlPull(projectId: string, uploadsDir: string, options = {}) {
                                return this.xhr
                                    .post(&#x60;/gdc/md/${projectId}/etl/pull2&#x60;, { body: { pullIntegration: uploadsDir } })
                                    .then((r: ApiResponse) =&gt; r.getData())
                                    .then((response: any) =&gt; {
                                        const etlPullStatusUri = response.pull2Task.links.poll;
                                        return handlePolling(
                                            this.xhr.get.bind(this.xhr),
                                            etlPullStatusUri,
                                            this.isTaskFinished,
                                            options,
                                        );
                                    })
                                    .then(this.checkStatusForError);
                            }
                        
                            private isTaskFinished(task: any) {
                                const taskState = task.wTaskStatus.status;
                                return taskState === &quot;OK&quot; || taskState === &quot;ERROR&quot;;
                            }
                        
                            private checkStatusForError(response: any) {
                                if (response.wTaskStatus.status === &quot;ERROR&quot;) {
                                    return Promise.reject(response);
                                }
                                return response;
                            }
                        }
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

