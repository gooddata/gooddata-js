---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/admin.html">admin</a></li>
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/user.html">user</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/admin.html">admin</a></li>
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/user.html">user</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v1.5.1</span>
                        <h1 class="file-heading">File: src/execution.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // Copyright (C) 2007-2014, GoodData(R) Corporation. All rights reserved.
                        import md5 from &#x27;md5&#x27;;
                        import invariant from &#x27;invariant&#x27;;
                        import {
                            compact,
                            filter,
                            first,
                            find,
                            map,
                            every,
                            get,
                            isEmpty,
                            isString,
                            negate,
                            last,
                            assign,
                            partial,
                            flatten,
                            omit
                        } from &#x27;lodash&#x27;;
                        
                        import {
                            ajax,
                            post,
                            get as xhrGet,
                            parseJSON
                        } from &#x27;./xhr&#x27;;
                        
                        import Rules from &#x27;./utils/rules&#x27;;
                        import { sortDefinitions } from &#x27;./utils/definitions&#x27;;
                        
                        const notEmpty = negate(isEmpty);
                        
                        const findHeaderForMappingFn = (mapping, header) =&gt;
                            ((mapping.element === header.id || mapping.element === header.uri) &amp;&amp;
                                header.measureIndex === undefined);
                        
                        
                        const wrapMeasureIndexesFromMappings = (metricMappings, headers) =&gt; {
                            if (metricMappings) {
                                metricMappings.forEach((mapping) =&gt; {
                                    const header = find(headers, partial(findHeaderForMappingFn, mapping));
                                    if (header) {
                                        header.measureIndex = mapping.measureIndex;
                                        header.isPoP = mapping.isPoP;
                                    }
                                });
                            }
                            return headers;
                        };
                        
                        /**
                         * Module for execution on experimental execution resource
                         *
                         * @class execution
                         * @module execution
                         */
                        
                        /**
                         * For the given projectId it returns table structure with the given
                         * elements in column headers.
                         *
                         * @method getData
                         * @param {String} projectId - GD project identifier
                         * @param {Array} columns - An array of attribute or metric identifiers.
                         * @param {Object} executionConfiguration - Execution configuration - can contain for example
                         *                 property &quot;filters&quot; containing execution context filters
                         *                 property &quot;where&quot; containing query-like filters
                         *                 property &quot;orderBy&quot; contains array of sorted properties to order in form
                         *                      [{column: &#x27;identifier&#x27;, direction: &#x27;asc|desc&#x27;}]
                         * @param {Object} settings - Set &quot;extended&quot; to true to retrieve the result
                         *                            including internal attribute IDs (useful to construct filters
                         *                            for subsequent report execution requests).
                         *                             Supports additional settings accepted by the underlying
                         *                             xhr.ajax() calls
                         *
                         * @return {Object} Structure with &#x60;headers&#x60; and &#x60;rawData&#x60; keys filled with values from execution.
                         */
                        export function getData(projectId, columns, executionConfiguration = {}, settings = {}) {
                            const executedReport = {
                                isLoaded: false
                            };
                        
                            // Extended result exposes internal attribute element IDs which can
                            // be used when constructing executionConfiguration filters for
                            // subsequent report execution requests
                            const resultKey = settings.extended ? &#x27;extendedTabularDataResult&#x27; : &#x27;tabularDataResult&#x27;;
                            // Create request and result structures
                            const request = {
                                execution: { columns }
                            };
                            // enrich configuration with supported properties such as
                            // where clause with query-like filters or execution context filters
                            [&#x27;filters&#x27;, &#x27;where&#x27;, &#x27;orderBy&#x27;, &#x27;definitions&#x27;].forEach((property) =&gt; {
                                if (executionConfiguration[property]) {
                                    request.execution[property] = executionConfiguration[property];
                                }
                            });
                        
                            // Execute request
                            return post(&#x60;/gdc/internal/projects/${projectId}/experimental/executions&#x60;, {
                                ...settings,
                                body: JSON.stringify(request)
                            })
                            .then(parseJSON)
                            .then((result) =&gt; {
                                executedReport.headers = wrapMeasureIndexesFromMappings(
                                    get(executionConfiguration, &#x27;metricMappings&#x27;), result.executionResult.headers);
                        
                                // Start polling on url returned in the executionResult for tabularData
                                return ajax(result.executionResult[resultKey], settings);
                            })
                            .then((r) =&gt; {
                                if (r.status === 204) {
                                    return {
                                        status: r.status,
                                        result: &#x27;&#x27;
                                    };
                                }
                        
                                return r.json().then((result) =&gt; {
                                    return {
                                        status: r.status,
                                        result
                                    };
                                });
                            })
                            .then((r) =&gt; {
                                const { result, status } = r;
                        
                                return Object.assign({}, executedReport, {
                                    rawData: get(result, &#x60;${resultKey}.values&#x60;, []),
                                    warnings: get(result, &#x60;${resultKey}.warnings&#x60;, []),
                                    isLoaded: true,
                                    isEmpty: status === 204
                                });
                            });
                        }
                        
                        const MAX_TITLE_LENGTH = 255;
                        const getMetricTitle = (suffix, title) =&gt; {
                            const maxLength = MAX_TITLE_LENGTH - suffix.length;
                            if (title &amp;&amp; title.length &gt; maxLength) {
                                if (title[title.length - 1] === &#x27;)&#x27;) {
                                    return &#x60;${title.substring(0, maxLength - 2)}…)${suffix}&#x60;;
                                }
                                return &#x60;${title.substring(0, maxLength - 1)}…${suffix}&#x60;;
                            }
                            return &#x60;${title}${suffix}&#x60;;
                        };
                        
                        const getBaseMetricTitle = partial(getMetricTitle, &#x27;&#x27;);
                        
                        const POP_SUFFIX = &#x27; - previous year&#x27;;
                        const getPoPMetricTitle = partial(getMetricTitle, POP_SUFFIX);
                        
                        const CONTRIBUTION_METRIC_FORMAT = &#x27;#,##0.00%&#x27;;
                        
                        const allFiltersEmpty = item =&gt; every(map(
                            get(item, &#x27;measureFilters&#x27;, []),
                            f =&gt; isEmpty(get(f, &#x27;listAttributeFilter.default.attributeElements&#x27;, []))
                        ));
                        
                        const isDerived = (measure) =&gt; {
                            const type = get(measure, &#x27;type&#x27;);
                            return (type === &#x27;fact&#x27; || type === &#x27;attribute&#x27; || !allFiltersEmpty(measure));
                        };
                        
                        const getFilterExpression = (listAttributeFilter) =&gt; {
                            const attributeUri = get(listAttributeFilter, &#x27;listAttributeFilter.attribute&#x27;);
                            const elements = get(listAttributeFilter, &#x27;listAttributeFilter.default.attributeElements&#x27;, []);
                            if (isEmpty(elements)) {
                                return null;
                            }
                            const elementsForQuery = map(elements, e =&gt; &#x60;[${e}]&#x60;);
                            const negative = get(listAttributeFilter, &#x27;listAttributeFilter.default.negativeSelection&#x27;) ? &#x27;NOT &#x27; : &#x27;&#x27;;
                        
                            return &#x60;[${attributeUri}] ${negative}IN (${elementsForQuery.join(&#x27;,&#x27;)})&#x60;;
                        };
                        
                        const getGeneratedMetricExpression = (item) =&gt; {
                            const aggregation = get(item, &#x27;aggregation&#x27;, &#x27;&#x27;).toUpperCase();
                            const objectUri = get(item, &#x27;objectUri&#x27;);
                            const where = filter(map(get(item, &#x27;measureFilters&#x27;), getFilterExpression), e =&gt; !!e);
                        
                            return &#x60;SELECT ${aggregation ? &#x60;${aggregation}([${objectUri}])&#x60; : &#x60;[${objectUri}]&#x60;
                                }${notEmpty(where) ? &#x60; WHERE ${where.join(&#x27; AND &#x27;)}&#x60; : &#x27;&#x27;}&#x60;;
                        };
                        
                        const getPercentMetricExpression = ({ category }, measure) =&gt; {
                            let metricExpressionWithoutFilters = &#x60;SELECT [${get(measure, &#x27;objectUri&#x27;)}]&#x60;;
                        
                            if (isDerived(measure)) {
                                metricExpressionWithoutFilters = getGeneratedMetricExpression(omit(measure, &#x27;measureFilters&#x27;));
                            }
                        
                            const attributeUri = get(category, &#x27;attribute&#x27;);
                            const whereFilters = filter(map(get(measure, &#x27;measureFilters&#x27;), getFilterExpression), e =&gt; !!e);
                            const whereExpression = notEmpty(whereFilters) ? &#x60; WHERE ${whereFilters.join(&#x27; AND &#x27;)}&#x60; : &#x27;&#x27;;
                        
                            return &#x60;SELECT (${metricExpressionWithoutFilters}${whereExpression}) / (${metricExpressionWithoutFilters} BY ALL [${attributeUri}]${whereExpression})&#x60;;
                        };
                        
                        const getPoPExpression = (attribute, metricExpression) =&gt; {
                            const attributeUri = get(attribute, &#x27;attribute&#x27;);
                        
                            return &#x60;SELECT ${metricExpression} FOR PREVIOUS ([${attributeUri}])&#x60;;
                        };
                        
                        const getGeneratedMetricHash = (title, format, expression) =&gt; md5(&#x60;${expression}#${title}#${format}&#x60;);
                        
                        const getGeneratedMetricIdentifier = (item, aggregation, expressionCreator, hasher) =&gt; {
                            const [, , , prjId, , id] = get(item, &#x27;objectUri&#x27;).split(&#x27;/&#x27;);
                            const identifier = &#x60;${prjId}_${id}&#x60;;
                            const hash = hasher(expressionCreator(item));
                            const hasNoFilters = isEmpty(get(item, &#x27;measureFilters&#x27;, []));
                            const type = get(item, &#x27;type&#x27;);
                        
                            const prefix = (hasNoFilters || allFiltersEmpty(item)) ? &#x27;&#x27; : &#x27;_filtered&#x27;;
                        
                            return &#x60;${type}_${identifier}.generated.${hash}${prefix}_${aggregation}&#x60;;
                        };
                        
                        const isDateCategory = ({ category }) =&gt; category.type === &#x27;date&#x27;;
                        const isDateFilter = ({ dateFilter }) =&gt; dateFilter;
                        
                        const getCategories = ({ categories }) =&gt; categories;
                        const getFilters = ({ filters }) =&gt; filters;
                        
                        const getDateCategory = (mdObj) =&gt; {
                            const category = find(getCategories(mdObj), isDateCategory);
                        
                            return get(category, &#x27;category&#x27;);
                        };
                        
                        const getDateFilter = (mdObj) =&gt; {
                            const dateFilter = find(getFilters(mdObj), isDateFilter);
                        
                            return get(dateFilter, &#x27;dateFilter&#x27;);
                        };
                        
                        const getDate = mdObj =&gt; (getDateCategory(mdObj) || getDateFilter(mdObj));
                        
                        const getMetricSort = (sort, isPoPMetric) =&gt; {
                            if (isString(sort)) {
                                // TODO: backward compatibility, remove when not used plain &quot;sort: asc | desc&quot; in measures
                                return sort;
                            }
                        
                            const sortByPoP = get(sort, &#x27;sortByPoP&#x27;);
                            if ((isPoPMetric &amp;&amp; sortByPoP) || (!isPoPMetric &amp;&amp; !sortByPoP)) {
                                return get(sort, &#x27;direction&#x27;);
                            }
                            return null;
                        };
                        
                        const createPureMetric = (measure, mdObj, measureIndex) =&gt; ({
                            element: get(measure, &#x27;objectUri&#x27;),
                            sort: getMetricSort(get(measure, &#x27;sort&#x27;)),
                            meta: { measureIndex }
                        });
                        
                        const createDerivedMetric = (measure, mdObj, measureIndex) =&gt; {
                            const { format, sort } = measure;
                            const title = getBaseMetricTitle(measure.title);
                        
                            const hasher = partial(getGeneratedMetricHash, title, format);
                            const aggregation = get(measure, &#x27;aggregation&#x27;, &#x27;base&#x27;).toLowerCase();
                            const element = getGeneratedMetricIdentifier(measure, aggregation, getGeneratedMetricExpression, hasher);
                            const definition = {
                                metricDefinition: {
                                    identifier: element,
                                    expression: getGeneratedMetricExpression(measure),
                                    title,
                                    format
                                }
                            };
                        
                            return {
                                element,
                                definition,
                                sort: getMetricSort(sort),
                                meta: {
                                    measureIndex
                                }
                            };
                        };
                        
                        const createContributionMetric = (measure, mdObj, measureIndex) =&gt; {
                            const category = first(getCategories(mdObj));
                            const getMetricExpression = partial(getPercentMetricExpression, category);
                            const title = getBaseMetricTitle(get(measure, &#x27;title&#x27;));
                            const hasher = partial(getGeneratedMetricHash, title, CONTRIBUTION_METRIC_FORMAT);
                            return {
                                element: getGeneratedMetricIdentifier(measure, &#x27;percent&#x27;, getMetricExpression, hasher),
                                definition: {
                                    metricDefinition: {
                                        identifier: getGeneratedMetricIdentifier(measure, &#x27;percent&#x27;, getMetricExpression, hasher),
                                        expression: getMetricExpression(measure),
                                        title,
                                        format: CONTRIBUTION_METRIC_FORMAT
                                    }
                                },
                                sort: getMetricSort(get(measure, &#x27;sort&#x27;)),
                                meta: {
                                    measureIndex
                                }
                            };
                        };
                        
                        const createPoPMetric = (measure, mdObj, measureIndex) =&gt; {
                            const title = getPoPMetricTitle(get(measure, &#x27;title&#x27;));
                            const format = get(measure, &#x27;format&#x27;);
                            const hasher = partial(getGeneratedMetricHash, title, format);
                        
                            const date = getDate(mdObj);
                        
                            let generated;
                            let getMetricExpression = partial(getPoPExpression, date, &#x60;[${get(measure, &#x27;objectUri&#x27;)}]&#x60;);
                        
                            if (isDerived(measure)) {
                                generated = createDerivedMetric(measure, mdObj, measureIndex);
                                getMetricExpression = partial(getPoPExpression, date, &#x60;(${get(generated, &#x27;definition.metricDefinition.expression&#x27;)})&#x60;);
                            }
                        
                            const identifier = getGeneratedMetricIdentifier(measure, &#x27;pop&#x27;, getMetricExpression, hasher);
                        
                            const result = [{
                                element: identifier,
                                definition: {
                                    metricDefinition: {
                                        identifier,
                                        expression: getMetricExpression(),
                                        title,
                                        format
                                    }
                                },
                                sort: getMetricSort(get(measure, &#x27;sort&#x27;), true),
                                meta: {
                                    measureIndex,
                                    isPoP: true
                                }
                            }];
                        
                            if (generated) {
                                result.push(generated);
                            } else {
                                result.push(createPureMetric(measure, mdObj, measureIndex));
                            }
                        
                            return result;
                        };
                        
                        const createContributionPoPMetric = (measure, mdObj, measureIndex) =&gt; {
                            const date = getDate(mdObj);
                        
                            const generated = createContributionMetric(measure, mdObj, measureIndex);
                            const title = getPoPMetricTitle(get(measure, &#x27;title&#x27;));
                        
                            const format = CONTRIBUTION_METRIC_FORMAT;
                            const hasher = partial(getGeneratedMetricHash, title, format);
                        
                            const getMetricExpression = partial(getPoPExpression, date, &#x60;(${get(generated, &#x27;definition.metricDefinition.expression&#x27;)})&#x60;);
                        
                            const identifier = getGeneratedMetricIdentifier(measure, &#x27;pop&#x27;, getMetricExpression, hasher);
                        
                            const result = [{
                                element: identifier,
                                definition: {
                                    metricDefinition: {
                                        identifier,
                                        expression: getMetricExpression(),
                                        title,
                                        format
                                    }
                                },
                                sort: getMetricSort(get(measure, &#x27;sort&#x27;), true),
                                meta: {
                                    measureIndex,
                                    isPoP: true
                                }
                            }];
                        
                            result.push(generated);
                        
                            return result;
                        };
                        
                        const categoryToElement = ({ category }) =&gt;
                            ({ element: get(category, &#x27;displayForm&#x27;), sort: get(category, &#x27;sort&#x27;) });
                        
                        const attributeFilterToWhere = (f) =&gt; {
                            const elements = get(f, &#x27;listAttributeFilter.default.attributeElements&#x27;, []);
                            const elementsForQuery = map(elements, e =&gt; ({ id: last(e.split(&#x27;=&#x27;)) }));
                        
                            const dfUri = get(f, &#x27;listAttributeFilter.displayForm&#x27;);
                            const negative = get(f, &#x27;listAttributeFilter.default.negativeSelection&#x27;);
                        
                            return negative ?
                                { [dfUri]: { $not: { $in: elementsForQuery } } } :
                                { [dfUri]: { $in: elementsForQuery } };
                        };
                        
                        const dateFilterToWhere = (f) =&gt; {
                            const dateUri =
                                get(f, &#x27;dateFilter.dimension&#x27;) ||
                                get(f, &#x27;dateFilter.dataSet&#x27;) ||
                                get(f, &#x27;dateFilter.dataset&#x27;); // dataset with lowercase &#x27;s&#x27; is deprecated; kept here for backwards compatibility
                            const granularity = get(f, &#x27;dateFilter.granularity&#x27;);
                            const between = [get(f, &#x27;dateFilter.from&#x27;), get(f, &#x27;dateFilter.to&#x27;)];
                            return { [dateUri]: { $between: between, $granularity: granularity } };
                        };
                        
                        const isPoP = ({ showPoP }) =&gt; showPoP;
                        const isContribution = ({ showInPercent }) =&gt; showInPercent;
                        
                        const isCalculatedMeasure = ({ type }) =&gt; type === &#x27;metric&#x27;;
                        
                        const rules = new Rules();
                        
                        rules.addRule(
                            [isPoP, isContribution],
                            createContributionPoPMetric
                        );
                        
                        rules.addRule(
                            [isPoP],
                            createPoPMetric
                        );
                        
                        rules.addRule(
                            [isContribution],
                            createContributionMetric
                        );
                        
                        rules.addRule(
                            [isDerived],
                            createDerivedMetric
                        );
                        
                        rules.addRule(
                            [isCalculatedMeasure],
                            createPureMetric
                        );
                        
                        function getMetricFactory(measure) {
                            const factory = rules.match(measure);
                        
                            invariant(factory, &#x60;Unknown factory for: ${measure}&#x60;);
                        
                            return factory;
                        }
                        
                        const isDateFilterExecutable = dateFilter =&gt;
                            get(dateFilter, &#x27;from&#x27;) !== undefined &amp;&amp;
                            get(dateFilter, &#x27;to&#x27;) !== undefined;
                        
                        const isAttributeFilterExecutable = listAttributeFilter =&gt;
                            notEmpty(get(listAttributeFilter, [&#x27;default&#x27;, &#x27;attributeElements&#x27;]));
                        
                        
                        function getWhere(filters) {
                            const executableFilters = filter(
                                filters, ({ listAttributeFilter }) =&gt; isAttributeFilterExecutable(listAttributeFilter)
                            );
                            const attributeFilters = map(executableFilters, attributeFilterToWhere);
                            const dateFilters = map(filter(filters, ({ dateFilter }) =&gt; isDateFilterExecutable(dateFilter)), dateFilterToWhere);
                        
                            const resultDate = [...dateFilters].reduce(assign, {});
                            const resultAttribute = {
                                $and: attributeFilters
                            };
                        
                            return {
                                ...resultDate,
                                ...resultAttribute
                            };
                        }
                        
                        const sortToOrderBy = item =&gt; ({ column: get(item, &#x27;element&#x27;), direction: get(item, &#x27;sort&#x27;) });
                        
                        const getOrderBy = (metrics, categories, type) =&gt; {
                            // For bar chart we always override sorting to sort by values (first metric)
                            if (type === &#x27;bar&#x27; &amp;&amp; notEmpty(metrics)) {
                                return [{
                                    column: first(compact(map(metrics, &#x27;element&#x27;))),
                                    direction: &#x27;desc&#x27;
                                }];
                            }
                        
                            return map(filter([...categories, ...metrics], item =&gt; item.sort), sortToOrderBy);
                        };
                        
                        export const mdToExecutionConfiguration = (mdObj, options = {}) =&gt; {
                            const buckets = get(mdObj, &#x27;buckets&#x27;);
                            const measures = map(buckets.measures, ({ measure }) =&gt; measure);
                            const metrics = flatten(map(measures, (measure, index) =&gt; getMetricFactory(measure)(measure, buckets, index)));
                        
                            let categories = getCategories(buckets);
                            let filters = getFilters(buckets);
                            if (options.removeDateItems) {
                                categories = filter(categories, ({ category }) =&gt; category.type !== &#x27;date&#x27;);
                                filters = filter(filters, item =&gt; !item.dateFilter);
                            }
                            categories = map(categories, categoryToElement);
                        
                            const columns = compact(map([...categories, ...metrics], &#x27;element&#x27;));
                        
                            return {
                                columns,
                                orderBy: getOrderBy(metrics, categories, get(mdObj, &#x27;type&#x27;)),
                                definitions: sortDefinitions(compact(map(metrics, &#x27;definition&#x27;))),
                                where: columns.length ? getWhere(filters) : {},
                                metricMappings: map(metrics, m =&gt; ({ element: m.element, ...m.meta }))
                            };
                        };
                        
                        const getOriginalMetricFormats = (mdObj) =&gt; {
                            // for metrics with showPoP or measureFilters.length &gt; 0 roundtrip for original metric format
                            return Promise.all(map(
                                map(get(mdObj, &#x27;buckets.measures&#x27;), ({ measure }) =&gt; measure),
                                (measure) =&gt; {
                                    if (measure.showPoP === true || measure.measureFilters.length &gt; 0) {
                                        return xhrGet(measure.objectUri).then((obj) =&gt; {
                                            return {
                                                ...measure,
                                                format: get(obj, &#x27;metric.content.format&#x27;, measure.format)
                                            };
                                        });
                                    }
                        
                                    return Promise.resolve(measure);
                                }
                            ));
                        };
                        
                        export const getDataForVis = (projectId, mdObj, settings) =&gt; {
                            return getOriginalMetricFormats(mdObj).then((measures) =&gt; {
                                const metadata = mdObj;
                                metadata.buckets.measures = map(measures, measure =&gt; ({ measure }));
                                const { columns, ...executionConfiguration } = mdToExecutionConfiguration(mdObj);
                                return getData(projectId, columns, executionConfiguration, settings);
                            });
                        };
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

