---
layout: api
title: foobar
---
<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <div id="api-tabview" class="tabview">
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul class="tabs">
                                <li><a href="#api-modules" class="category">Modules</a>
                                    <ul id="api-modules" class="apis modules">
                                        <li><a href="../modules/config.html">config</a></li>
                                        <li><a href="../modules/DataLayer.html">DataLayer</a></li>
                                        <li><a href="../modules/execution.html">execution</a></li>
                                        <li><a href="../modules/metadata.html">metadata</a></li>
                                        <li><a href="../modules/project.html">project</a></li>
                                        <li><a href="../modules/report.html">report</a></li>
                                        <li><a href="../modules/sdk.html">sdk</a></li>
                                        <li><a href="../modules/util.html">util</a></li>
                                        <li><a href="../modules/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                                <li><a href="#api-classes" class="category">Classes</a>
                                    <ul id="api-classes" class="apis classes">
                                        <li><a href="../classes/config.html">config</a></li>
                                        <li><a href="../classes/DataLayer.html">DataLayer</a></li>
                                        <li><a href="../classes/execution.html">execution</a></li>
                                        <li><a href="../classes/metadata.html">metadata</a></li>
                                        <li><a href="../classes/project.html">project</a></li>
                                        <li><a href="../classes/report.html">report</a></li>
                                        <li><a href="../classes/sdk.html">sdk</a></li>
                                        <li><a href="../classes/util.html">util</a></li>
                                        <li><a href="../classes/xhr.html">xhr</a></li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <strong>gooddata-js</strong> <span class="version">v13.5.0</span>
                        <h1 class="file-heading">File: src/execution/experimental-executions.ts</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        // (C) 2007-2020 GoodData Corporation
                        import md5 from &quot;md5&quot;;
                        import invariant from &quot;invariant&quot;;
                        import cloneDeep from &quot;lodash/cloneDeep&quot;;
                        import compact from &quot;lodash/compact&quot;;
                        import filter from &quot;lodash/filter&quot;;
                        import first from &quot;lodash/first&quot;;
                        import find from &quot;lodash/find&quot;;
                        import map from &quot;lodash/map&quot;;
                        import merge from &quot;lodash/merge&quot;;
                        import every from &quot;lodash/every&quot;;
                        import get from &quot;lodash/get&quot;;
                        import isEmpty from &quot;lodash/isEmpty&quot;;
                        import negate from &quot;lodash/negate&quot;;
                        import partial from &quot;lodash/partial&quot;;
                        import flatten from &quot;lodash/flatten&quot;;
                        import set from &quot;lodash/set&quot;;
                        
                        import { Rules } from &quot;../utils/rules&quot;;
                        import { sortDefinitions } from &quot;../utils/definitions&quot;;
                        import { getMissingUrisInAttributesMap } from &quot;../utils/attributesMapLoader&quot;;
                        import {
                            getAttributes,
                            getAttributesDisplayForms,
                            getDefinition,
                            getMeasureFilters,
                            getMeasures,
                            isAttributeMeasureFilter,
                        } from &quot;../utils/visualizationObjectHelper&quot;;
                        import { IMeasure } from &quot;../interfaces&quot;;
                        import { XhrModule } from &quot;../xhr&quot;;
                        
                        const notEmpty = negate(isEmpty);
                        
                        function findHeaderForMappingFn(mapping: any, header: any) {
                            return (
                                (mapping.element === header.id || mapping.element === header.uri) &amp;&amp; header.measureIndex === undefined
                            );
                        }
                        
                        function wrapMeasureIndexesFromMappings(metricMappings: any[], headers: any[]) {
                            if (metricMappings) {
                                metricMappings.forEach(mapping =&gt; {
                                    const header = find(headers, partial(findHeaderForMappingFn, mapping));
                                    if (header) {
                                        header.measureIndex = mapping.measureIndex;
                                        header.isPoP = mapping.isPoP;
                                    }
                                });
                            }
                            return headers;
                        }
                        
                        const emptyResult = {
                            extendedTabularDataResult: {
                                values: [],
                                warnings: [],
                            },
                        };
                        
                        const MAX_TITLE_LENGTH = 1000;
                        
                        function getMetricTitle(suffix: string, title: string) {
                            const maxLength = MAX_TITLE_LENGTH - suffix.length;
                            if (title &amp;&amp; title.length &gt; maxLength) {
                                if (title[title.length - 1] === &quot;)&quot;) {
                                    return &#x60;${title.substring(0, maxLength - 2)}…)${suffix}&#x60;;
                                }
                                return &#x60;${title.substring(0, maxLength - 1)}…${suffix}&#x60;;
                            }
                            return &#x60;${title}${suffix}&#x60;;
                        }
                        
                        const getBaseMetricTitle = partial(getMetricTitle, &quot;&quot;);
                        
                        const CONTRIBUTION_METRIC_FORMAT = &quot;#,##0.00%&quot;;
                        
                        function getPoPDefinition(measure: IMeasure) {
                            return get(measure, [&quot;definition&quot;, &quot;popMeasureDefinition&quot;], {});
                        }
                        
                        function getAggregation(measure: IMeasure) {
                            return get(getDefinition(measure), &quot;aggregation&quot;, &quot;&quot;).toLowerCase();
                        }
                        
                        function isEmptyFilter(metricFilter: any) {
                            if (get(metricFilter, &quot;positiveAttributeFilter&quot;)) {
                                return isEmpty(get(metricFilter, [&quot;positiveAttributeFilter&quot;, &quot;in&quot;]));
                            }
                            if (get(metricFilter, &quot;negativeAttributeFilter&quot;)) {
                                return isEmpty(get(metricFilter, [&quot;negativeAttributeFilter&quot;, &quot;notIn&quot;]));
                            }
                            if (get(metricFilter, &quot;absoluteDateFilter&quot;)) {
                                return (
                                    get(metricFilter, [&quot;absoluteDateFilter&quot;, &quot;from&quot;]) === undefined &amp;&amp;
                                    get(metricFilter, [&quot;absoluteDateFilter&quot;, &quot;to&quot;]) === undefined
                                );
                            }
                            return (
                                get(metricFilter, [&quot;relativeDateFilter&quot;, &quot;from&quot;]) === undefined &amp;&amp;
                                get(metricFilter, [&quot;relativeDateFilter&quot;, &quot;to&quot;]) === undefined
                            );
                        }
                        
                        function allFiltersEmpty(item: any) {
                            return every(map(getMeasureFilters(item), f =&gt; isEmptyFilter(f)));
                        }
                        
                        function isDerived(measure: any) {
                            const aggregation = getAggregation(measure);
                            return aggregation !== &quot;&quot; || !allFiltersEmpty(measure);
                        }
                        
                        function getAttrTypeFromMap(dfUri: string, attributesMap: any) {
                            return get(get(attributesMap, [dfUri], {}), [&quot;attribute&quot;, &quot;content&quot;, &quot;type&quot;]);
                        }
                        
                        function getAttrUriFromMap(dfUri: string, attributesMap: any) {
                            return get(get(attributesMap, [dfUri], {}), [&quot;attribute&quot;, &quot;meta&quot;, &quot;uri&quot;]);
                        }
                        
                        function isAttrFilterNegative(attributeFilter: any) {
                            return get(attributeFilter, &quot;negativeAttributeFilter&quot;) !== undefined;
                        }
                        
                        function getAttrFilterElements(attributeFilter: any) {
                            const isNegative = isAttrFilterNegative(attributeFilter);
                            const pathToElements = isNegative
                                ? [&quot;negativeAttributeFilter&quot;, &quot;notIn&quot;]
                                : [&quot;positiveAttributeFilter&quot;, &quot;in&quot;];
                            return get(attributeFilter, pathToElements, []);
                        }
                        
                        function getAttrFilterExpression(measureFilter: any, attributesMap: any) {
                            const isNegative = get(measureFilter, &quot;negativeAttributeFilter&quot;, false);
                            const detailPath = isNegative ? &quot;negativeAttributeFilter&quot; : &quot;positiveAttributeFilter&quot;;
                            const attributeUri = getAttrUriFromMap(
                                get(measureFilter, [detailPath, &quot;displayForm&quot;, &quot;uri&quot;]),
                                attributesMap,
                            );
                            const elements = getAttrFilterElements(measureFilter);
                            if (isEmpty(elements)) {
                                return null;
                            }
                            const elementsForQuery = map(elements, e =&gt; &#x60;[${e}]&#x60;);
                            const negative = isNegative ? &quot;NOT &quot; : &quot;&quot;;
                        
                            return &#x60;[${attributeUri}] ${negative}IN (${elementsForQuery.join(&quot;,&quot;)})&#x60;;
                        }
                        
                        function getDateFilterExpression() {
                            // measure date filter was never supported
                            return &quot;&quot;;
                        }
                        
                        function getFilterExpression(attributesMap: any, measureFilter: any) {
                            if (isAttributeMeasureFilter(measureFilter)) {
                                return getAttrFilterExpression(measureFilter, attributesMap);
                            }
                            return getDateFilterExpression();
                        }
                        
                        function getGeneratedMetricExpression(item: any, attributesMap: any) {
                            const aggregation = getAggregation(item).toUpperCase();
                            const objectUri = get(getDefinition(item), &quot;item.uri&quot;);
                            const where = filter(map(getMeasureFilters(item), partial(getFilterExpression, attributesMap)), e =&gt; !!e);
                        
                            return &#x60;SELECT ${aggregation ? &#x60;${aggregation}([${objectUri}])&#x60; : &#x60;[${objectUri}]&#x60;}${
                                notEmpty(where) ? &#x60; WHERE ${where.join(&quot; AND &quot;)}&#x60; : &quot;&quot;
                            }&#x60;;
                        }
                        
                        function getPercentMetricExpression(category: any, attributesMap: any, measure: any) {
                            let metricExpressionWithoutFilters = &#x60;SELECT [${get(getDefinition(measure), &quot;item.uri&quot;)}]&#x60;;
                        
                            if (isDerived(measure)) {
                                metricExpressionWithoutFilters = getGeneratedMetricExpression(
                                    set(cloneDeep(measure), [&quot;definition&quot;, &quot;measureDefinition&quot;, &quot;filters&quot;], []),
                                    attributesMap,
                                );
                            }
                        
                            const attributeUri = getAttrUriFromMap(get(category, &quot;displayForm.uri&quot;), attributesMap);
                            const whereFilters = filter(
                                map(getMeasureFilters(measure), partial(getFilterExpression, attributesMap)),
                                e =&gt; !!e,
                            );
                            const whereExpression = notEmpty(whereFilters) ? &#x60; WHERE ${whereFilters.join(&quot; AND &quot;)}&#x60; : &quot;&quot;;
                        
                            // tslint:disable-next-line:max-line-length
                            return &#x60;SELECT (${metricExpressionWithoutFilters}${whereExpression}) / (${metricExpressionWithoutFilters} BY ALL [${attributeUri}]${whereExpression})&#x60;;
                        }
                        
                        function getPoPExpression(attributeUri: string, metricExpression: string) {
                            return &#x60;SELECT ${metricExpression} FOR PREVIOUS ([${attributeUri}])&#x60;;
                        }
                        
                        function getGeneratedMetricHash(title: string, format: string, expression: string) {
                            return md5(&#x60;${expression}#${title}#${format}&#x60;);
                        }
                        
                        function getMeasureType(measure: any) {
                            const aggregation = getAggregation(measure);
                            if (aggregation === &quot;&quot;) {
                                return &quot;metric&quot;;
                            } else if (aggregation === &quot;count&quot;) {
                                return &quot;attribute&quot;;
                            }
                            return &quot;fact&quot;;
                        }
                        
                        function getGeneratedMetricIdentifier(
                            item: any,
                            aggregation: string,
                            expressionCreator: (item: any, attributesMap: any) =&gt; string,
                            hasher: any,
                            attributesMap: any,
                        ) {
                            const [, , , prjId, , id] = get(getDefinition(item), &quot;item.uri&quot;, &quot;&quot;).split(&quot;/&quot;);
                            const identifier = &#x60;${prjId}_${id}&#x60;;
                            const hash = hasher(expressionCreator(item, attributesMap));
                            const hasNoFilters = isEmpty(getMeasureFilters(item));
                            const type = getMeasureType(item);
                        
                            const prefix = hasNoFilters || allFiltersEmpty(item) ? &quot;&quot; : &quot;_filtered&quot;;
                        
                            return &#x60;${type}_${identifier}.generated.${hash}${prefix}_${aggregation}&#x60;;
                        }
                        
                        function isDateAttribute(attribute: any, attributesMap = {}) {
                            return getAttrTypeFromMap(get(attribute, [&quot;displayForm&quot;, &quot;uri&quot;]), attributesMap) !== undefined;
                        }
                        
                        function getMeasureSorting(measure?: any, mdObj?: any) {
                            const sorting = get(mdObj, [&quot;properties&quot;, &quot;sortItems&quot;], []);
                            const matchedSorting = sorting.find((sortItem: any) =&gt; {
                                const measureSortItem = get(sortItem, [&quot;measureSortItem&quot;]);
                                if (measureSortItem) {
                                    // only one item now, we support only 2d data
                                    const identifier = get(measureSortItem, [
                                        &quot;locators&quot;,
                                        0,
                                        &quot;measureLocatorItem&quot;,
                                        &quot;measureIdentifier&quot;,
                                    ]);
                                    return identifier === get(measure, &quot;localIdentifier&quot;);
                                }
                                return false;
                            });
                            if (matchedSorting) {
                                return get(matchedSorting, [&quot;measureSortItem&quot;, &quot;direction&quot;], null);
                            }
                            return null;
                        }
                        
                        function getCategorySorting(category: any, mdObj: any) {
                            const sorting = get(mdObj, [&quot;properties&quot;, &quot;sortItems&quot;], []);
                            const matchedSorting = sorting.find((sortItem: any) =&gt; {
                                const attributeSortItem = get(sortItem, [&quot;attributeSortItem&quot;]);
                                if (attributeSortItem) {
                                    const identifier = get(attributeSortItem, [&quot;attributeIdentifier&quot;]);
                                    return identifier === get(category, &quot;localIdentifier&quot;);
                                }
                                return false;
                            });
                            if (matchedSorting) {
                                return get(matchedSorting, [&quot;attributeSortItem&quot;, &quot;direction&quot;], null);
                            }
                            return null;
                        }
                        
                        const createPureMetric = (measure: any, mdObj: any, measureIndex: number) =&gt; ({
                            element: get(measure, [&quot;definition&quot;, &quot;measureDefinition&quot;, &quot;item&quot;, &quot;uri&quot;]),
                            sort: getMeasureSorting(measure, mdObj),
                            meta: { measureIndex },
                        });
                        
                        function createDerivedMetric(measure: any, mdObj: any, measureIndex: number, attributesMap: any) {
                            const { format } = measure;
                            const sort = getMeasureSorting(measure, mdObj);
                            const title = getBaseMetricTitle(measure.title);
                        
                            const hasher = partial(getGeneratedMetricHash, title, format);
                            const aggregation = getAggregation(measure);
                            const element = getGeneratedMetricIdentifier(
                                measure,
                                aggregation.length ? aggregation : &quot;base&quot;,
                                getGeneratedMetricExpression,
                                hasher,
                                attributesMap,
                            );
                            const definition = {
                                metricDefinition: {
                                    identifier: element,
                                    expression: getGeneratedMetricExpression(measure, attributesMap),
                                    title,
                                    format,
                                },
                            };
                        
                            return {
                                element,
                                definition,
                                sort,
                                meta: {
                                    measureIndex,
                                },
                            };
                        }
                        
                        function createContributionMetric(measure: any, mdObj: any, measureIndex: number, attributesMap: any) {
                            const attribute = first(getAttributes(mdObj));
                            const getMetricExpression = partial(getPercentMetricExpression, attribute, attributesMap);
                            const title = getBaseMetricTitle(get(measure, &quot;title&quot;));
                            const hasher = partial(getGeneratedMetricHash, title, CONTRIBUTION_METRIC_FORMAT);
                            const identifier = getGeneratedMetricIdentifier(
                                measure,
                                &quot;percent&quot;,
                                getMetricExpression,
                                hasher,
                                attributesMap,
                            );
                            return {
                                element: identifier,
                                definition: {
                                    metricDefinition: {
                                        identifier,
                                        expression: getMetricExpression(measure),
                                        title,
                                        format: CONTRIBUTION_METRIC_FORMAT,
                                    },
                                },
                                sort: getMeasureSorting(measure, mdObj),
                                meta: {
                                    measureIndex,
                                },
                            };
                        }
                        
                        function getOriginalMeasureForPoP(popMeasure: any, mdObj: any) {
                            return getMeasures(mdObj).find(
                                (measure: any) =&gt;
                                    get(measure, &quot;localIdentifier&quot;) === get(getPoPDefinition(popMeasure), [&quot;measureIdentifier&quot;]),
                            );
                        }
                        
                        function createPoPMetric(popMeasure: any, mdObj: any, measureIndex: number, attributesMap: any) {
                            const title = getBaseMetricTitle(get(popMeasure, &quot;title&quot;));
                            const format = get(popMeasure, &quot;format&quot;);
                            const hasher = partial(getGeneratedMetricHash, title, format);
                        
                            const attributeUri = get(popMeasure, &quot;definition.popMeasureDefinition.popAttribute.uri&quot;);
                            const originalMeasure = getOriginalMeasureForPoP(popMeasure, mdObj);
                        
                            const originalMeasureExpression = &#x60;[${get(getDefinition(originalMeasure), [&quot;item&quot;, &quot;uri&quot;])}]&#x60;;
                            let metricExpression = getPoPExpression(attributeUri, originalMeasureExpression);
                        
                            if (isDerived(originalMeasure)) {
                                const generated = createDerivedMetric(originalMeasure, mdObj, measureIndex, attributesMap);
                                const generatedMeasureExpression = &#x60;(${get(generated, [
                                    &quot;definition&quot;,
                                    &quot;metricDefinition&quot;,
                                    &quot;expression&quot;,
                                ])})&#x60;;
                                metricExpression = getPoPExpression(attributeUri, generatedMeasureExpression);
                            }
                        
                            const identifier = getGeneratedMetricIdentifier(
                                originalMeasure,
                                &quot;pop&quot;,
                                () =&gt; metricExpression,
                                hasher,
                                attributesMap,
                            );
                        
                            return {
                                element: identifier,
                                definition: {
                                    metricDefinition: {
                                        identifier,
                                        expression: metricExpression,
                                        title,
                                        format,
                                    },
                                },
                                sort: getMeasureSorting(popMeasure, mdObj),
                                meta: {
                                    measureIndex,
                                    isPoP: true,
                                },
                            };
                        }
                        
                        function createContributionPoPMetric(popMeasure: any, mdObj: any, measureIndex: number, attributesMap: any) {
                            const attributeUri = get(popMeasure, [&quot;definition&quot;, &quot;popMeasureDefinition&quot;, &quot;popAttribute&quot;, &quot;uri&quot;]);
                        
                            const originalMeasure = getOriginalMeasureForPoP(popMeasure, mdObj);
                        
                            const generated = createContributionMetric(originalMeasure, mdObj, measureIndex, attributesMap);
                            const title = getBaseMetricTitle(get(popMeasure, &quot;title&quot;));
                        
                            const format = CONTRIBUTION_METRIC_FORMAT;
                            const hasher = partial(getGeneratedMetricHash, title, format);
                        
                            const generatedMeasureExpression = &#x60;(${get(generated, [
                                &quot;definition&quot;,
                                &quot;metricDefinition&quot;,
                                &quot;expression&quot;,
                            ])})&#x60;;
                            const metricExpression = getPoPExpression(attributeUri, generatedMeasureExpression);
                        
                            const identifier = getGeneratedMetricIdentifier(
                                originalMeasure,
                                &quot;pop&quot;,
                                () =&gt; metricExpression,
                                hasher,
                                attributesMap,
                            );
                        
                            return {
                                element: identifier,
                                definition: {
                                    metricDefinition: {
                                        identifier,
                                        expression: metricExpression,
                                        title,
                                        format,
                                    },
                                },
                                sort: getMeasureSorting(),
                                meta: {
                                    measureIndex,
                                    isPoP: true,
                                },
                            };
                        }
                        
                        function categoryToElement(attributesMap: any, mdObj: any, category: any) {
                            const element = getAttrUriFromMap(get(category, [&quot;displayForm&quot;, &quot;uri&quot;]), attributesMap);
                            return {
                                element,
                                sort: getCategorySorting(category, mdObj),
                            };
                        }
                        
                        function isPoP({ definition }: any) {
                            return get(definition, &quot;popMeasureDefinition&quot;) !== undefined;
                        }
                        function isContribution({ definition }: any) {
                            return get(definition, [&quot;measureDefinition&quot;, &quot;computeRatio&quot;]);
                        }
                        function isPoPContribution(popMeasure: any, mdObj: any) {
                            if (isPoP(popMeasure)) {
                                const originalMeasure = getOriginalMeasureForPoP(popMeasure, mdObj);
                                return isContribution(originalMeasure);
                            }
                            return false;
                        }
                        function isCalculatedMeasure({ definition }: any) {
                            return get(definition, [&quot;measureDefinition&quot;, &quot;aggregation&quot;]) === undefined;
                        }
                        
                        const rules = new Rules();
                        
                        rules.addRule([isPoPContribution], createContributionPoPMetric);
                        
                        rules.addRule([isPoP], createPoPMetric);
                        
                        rules.addRule([isContribution], createContributionMetric);
                        
                        rules.addRule([isDerived], createDerivedMetric);
                        
                        rules.addRule([isCalculatedMeasure], createPureMetric);
                        
                        function getMetricFactory(measure: any, mdObj: any) {
                            const factory = rules.match(measure, mdObj);
                        
                            invariant(factory, &#x60;Unknown factory for: ${measure}&#x60;);
                        
                            return factory;
                        }
                        
                        function getExecutionDefinitionsAndColumns(mdObj: any, options: any, attributesMap: any) {
                            const measures = getMeasures(mdObj);
                            let attributes = getAttributes(mdObj);
                        
                            const metrics = flatten(
                                map(measures, (measure, index) =&gt;
                                    getMetricFactory(measure, mdObj)(measure, mdObj, index, attributesMap),
                                ),
                            );
                            if (options.removeDateItems) {
                                attributes = filter(attributes, attribute =&gt; !isDateAttribute(attribute, attributesMap));
                            }
                            attributes = map(attributes, partial(categoryToElement, attributesMap, mdObj));
                        
                            const columns = compact(map([...attributes, ...metrics], &quot;element&quot;));
                            return {
                                columns,
                                definitions: sortDefinitions(compact(map(metrics, &quot;definition&quot;))),
                            };
                        }
                        
                        /**
                         * Module for execution on experimental execution resource
                         *
                         * @class execution
                         * @module execution
                         * @deprecated The module is in maintenance mode only (just the the compilation issues are being fixed when
                         *      referenced utilities and interfaces are being changed) and is not being extended when AFM executor
                         *      have new functionality added.
                         */
                        export class ExperimentalExecutionsModule {
                            constructor(private xhr: XhrModule, private loadAttributesMap: any) {}
                        
                            /**
                             * For the given projectId it returns table structure with the given
                             * elements in column headers.
                             *
                             * @method getData
                             * @param {String} projectId - GD project identifier
                             * @param {Array} columns - An array of attribute or metric identifiers.
                             * @param {Object} executionConfiguration - Execution configuration - can contain for example
                             *                 property &quot;where&quot; containing query-like filters
                             *                 property &quot;orderBy&quot; contains array of sorted properties to order in form
                             *                      [{column: &#x27;identifier&#x27;, direction: &#x27;asc|desc&#x27;}]
                             * @param {Object} settings - Supports additional settings accepted by the underlying
                             *                             xhr.ajax() calls
                             *
                             * @return {Object} Structure with &#x60;headers&#x60; and &#x60;rawData&#x60; keys filled with values from execution.
                             */
                            public getData(projectId: string, columns: any[], executionConfiguration: any = {}, settings: any = {}) {
                                if (process.env.NODE_ENV !== &quot;test&quot;) {
                                    // tslint:disable-next-line:no-console
                                    console.warn(
                                        &quot;ExperimentalExecutionsModule is deprecated and is no longer being maintained. &quot; +
                                            &quot;Please migrate to the ExecuteAfmModule.&quot;,
                                    );
                                }
                        
                                const executedReport: any = {
                                    isLoaded: false,
                                };
                        
                                // Create request and result structures
                                const request: any = {
                                    execution: { columns },
                                };
                                // enrich configuration with supported properties such as
                                // where clause with query-like filters
                                [&quot;where&quot;, &quot;orderBy&quot;, &quot;definitions&quot;].forEach(property =&gt; {
                                    if (executionConfiguration[property]) {
                                        request.execution[property] = executionConfiguration[property];
                                    }
                                });
                        
                                // Execute request
                                return this.xhr
                                    .post(&#x60;/gdc/internal/projects/${projectId}/experimental/executions&#x60;, {
                                        ...settings,
                                        body: JSON.stringify(request),
                                    })
                                    .then(r =&gt; r.getData())
                                    .then(response =&gt; {
                                        executedReport.headers = wrapMeasureIndexesFromMappings(
                                            get(executionConfiguration, &quot;metricMappings&quot;),
                                            get(response, [&quot;executionResult&quot;, &quot;headers&quot;], []),
                                        );
                        
                                        // Start polling on url returned in the executionResult for tabularData
                                        return this.loadExtendedDataResults(
                                            response.executionResult.extendedTabularDataResult,
                                            settings,
                                        );
                                    })
                                    .then((r: any) =&gt; {
                                        const { result, status } = r;
                        
                                        return {
                                            ...executedReport,
                                            rawData: get(result, &quot;extendedTabularDataResult.values&quot;, []),
                                            warnings: get(result, &quot;extendedTabularDataResult.warnings&quot;, []),
                                            isLoaded: true,
                                            isEmpty: status === 204,
                                        };
                                    });
                            }
                        
                            public mdToExecutionDefinitionsAndColumns(projectId: string, mdObj: any, options = {}) {
                                const allDfUris = getAttributesDisplayForms(mdObj);
                                const attributesMapPromise = this.getAttributesMap(options, allDfUris, projectId);
                        
                                return attributesMapPromise.then((attributesMap: any) =&gt; {
                                    return getExecutionDefinitionsAndColumns(mdObj, options, attributesMap);
                                });
                            }
                        
                            private getAttributesMap(options: any, displayFormUris: string[], projectId: string) {
                                const attributesMap = get(options, &quot;attributesMap&quot;, {});
                        
                                const missingUris = getMissingUrisInAttributesMap(displayFormUris, attributesMap);
                                return this.loadAttributesMap(projectId, missingUris).then((result: any) =&gt; {
                                    return {
                                        ...attributesMap,
                                        ...result,
                                    };
                                });
                            }
                        
                            private loadExtendedDataResults(uri: string, settings: any, prevResult = emptyResult) {
                                return new Promise((resolve, reject) =&gt; {
                                    this.xhr
                                        .ajax(uri, settings)
                                        .then(r =&gt; {
                                            const { response } = r;
                        
                                            if (response.status === 204) {
                                                return {
                                                    status: response.status,
                                                    result: &quot;&quot;,
                                                };
                                            }
                        
                                            return {
                                                status: response.status,
                                                result: r.getData(),
                                            };
                                        })
                                        .then(({ status, result }) =&gt; {
                                            const values = [
                                                ...get(prevResult, &quot;extendedTabularDataResult.values&quot;, []),
                                                ...get(result, &quot;extendedTabularDataResult.values&quot;, []),
                                            ];
                        
                                            const warnings = [
                                                ...get(prevResult, &quot;extendedTabularDataResult.warnings&quot;, []),
                                                ...get(result, &quot;extendedTabularDataResult.warnings&quot;, []),
                                            ];
                        
                                            const updatedResult = merge({}, prevResult, {
                                                extendedTabularDataResult: {
                                                    values,
                                                    warnings,
                                                },
                                            });
                        
                                            const nextUri = get(result, &quot;extendedTabularDataResult.paging.next&quot;);
                                            if (nextUri) {
                                                resolve(this.loadExtendedDataResults(nextUri, settings, updatedResult));
                                            } else {
                                                resolve({ status, result: updatedResult });
                                            }
                                        }, reject);
                                });
                            }
                        }
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

